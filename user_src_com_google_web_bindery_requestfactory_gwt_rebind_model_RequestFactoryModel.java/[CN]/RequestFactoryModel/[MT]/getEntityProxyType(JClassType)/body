{
  entityProxyType=ModelUtils.ensureBaseType(entityProxyType);
  EntityProxyModel toReturn=peers.get(entityProxyType);
  if (toReturn == null) {
    EntityProxyModel.Builder inProgress=peerBuilders.get(entityProxyType);
    if (inProgress != null) {
      toReturn=inProgress.peek();
    }
  }
  if (toReturn == null) {
    EntityProxyModel.Builder builder=new EntityProxyModel.Builder();
    peerBuilders.put(entityProxyType,builder);
    builder.setQualifiedBinaryName(ModelUtils.getQualifiedBaseBinaryName(entityProxyType));
    builder.setQualifiedSourceName(ModelUtils.getQualifiedBaseSourceName(entityProxyType));
    if (entityProxyInterface.isAssignableFrom(entityProxyType)) {
      builder.setType(Type.ENTITY);
    }
 else     if (valueProxyInterface.isAssignableFrom(entityProxyType)) {
      builder.setType(Type.VALUE);
    }
 else {
      poison("The type %s is not assignable to either %s or %s",entityProxyInterface.getQualifiedSourceName(),valueProxyInterface.getQualifiedSourceName());
      die(poisonedMessage());
    }
    ProxyFor proxyFor=entityProxyType.getAnnotation(ProxyFor.class);
    ProxyForName proxyForName=entityProxyType.getAnnotation(ProxyForName.class);
    JsonRpcProxy jsonRpcProxy=entityProxyType.getAnnotation(JsonRpcProxy.class);
    if (proxyFor == null && proxyForName == null && jsonRpcProxy == null) {
      poison("The %s type does not have a @%s, @%s, or @%s annotation",entityProxyType.getQualifiedSourceName(),ProxyFor.class.getSimpleName(),ProxyForName.class.getSimpleName(),JsonRpcProxy.class.getSimpleName());
    }
    List<RequestMethod> requestMethods=new ArrayList<RequestMethod>();
    Map<String,JMethod> duplicatePropertyGetters=new HashMap<String,JMethod>();
    for (    JMethod method : entityProxyType.getInheritableMethods()) {
      if (method.getEnclosingType().equals(entityProxyInterface)) {
        continue;
      }
      RequestMethod.Builder methodBuilder=new RequestMethod.Builder();
      methodBuilder.setDeclarationMethod(method);
      JType transportedType;
      String name=method.getName();
      if (JBeanMethod.GET.matches(method)) {
        transportedType=method.getReturnType();
        String propertyName=JBeanMethod.GET.inferName(method);
        JMethod previouslySeen=duplicatePropertyGetters.get(propertyName);
        if (previouslySeen == null) {
          duplicatePropertyGetters.put(propertyName,method);
        }
 else {
          poison("Duplicate accessors for property %s: %s() and %s()",propertyName,previouslySeen.getName(),method.getName());
        }
      }
 else       if (JBeanMethod.SET.matches(method) || JBeanMethod.SET_BUILDER.matches(method)) {
        transportedType=method.getParameters()[0].getType();
      }
 else       if (name.equals("stableId") && method.getParameters().length == 0) {
        continue;
      }
 else {
        poison("The method %s is neither a getter nor a setter",method.getReadableDeclaration());
        continue;
      }
      validateTransportableType(methodBuilder,transportedType,false);
      RequestMethod requestMethod=methodBuilder.build();
      requestMethods.add(requestMethod);
    }
    builder.setRequestMethods(requestMethods);
    toReturn=builder.build();
    peers.put(entityProxyType,toReturn);
    peerBuilders.remove(entityProxyType);
  }
  return toReturn;
}
