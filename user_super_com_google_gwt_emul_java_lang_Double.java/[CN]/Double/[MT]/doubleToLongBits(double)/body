{
  long sign=(d < 0 ? SIGN_BIT : 0);
  long exponent=0;
  double absV=Math.abs(d);
  if (Double.isNaN(d)) {
    return (1L << (EXPONENT_BITSIZE - 1)) | NAN_MANTISSA;
  }
  if (Double.isInfinite(d)) {
    exponent=EXPONENT_MASK;
    absV=0.0;
  }
 else {
    if (absV == 0.0) {
      exponent=0L;
    }
 else {
      int guess=(int)Math.floor(Math.log(absV) / Math.log(2));
      guess=Math.max(-MAX_EXPONENT,Math.min(guess,MAX_EXPONENT));
      double exp=Math.pow(2,guess);
      absV=absV / exp;
      while (absV > 2.0) {
        guess++;
        absV/=2.0;
      }
      while (absV < 1 && guess > 0) {
        guess--;
        absV*=2;
      }
      exponent=(guess + EXPONENT_BIAS) << MANTISSA_BITSIZE;
    }
  }
  if (exponent <= BIASED_ZERO_EXPONENT) {
    absV/=2;
  }
  long mantissa=(long)((absV % 1) * MAX_MANTISSA_VALUE);
  return sign | exponent | (mantissa & MANTISSA_MASK);
}
