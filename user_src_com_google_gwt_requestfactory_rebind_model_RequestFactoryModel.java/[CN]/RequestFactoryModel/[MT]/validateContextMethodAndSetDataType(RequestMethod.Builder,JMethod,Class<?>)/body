{
  JClassType requestReturnType=method.getReturnType().isInterface();
  JClassType invocationReturnType;
  if (requestReturnType == null) {
    poison(badContextReturnType(method,requestInterface,instanceRequestInterface));
    return false;
  }
  Method domainMethod=validateExistsAndNotOverriden(method,serviceClass,false);
  if (domainMethod == null) {
    return false;
  }
  if (instanceRequestInterface.isAssignableFrom(requestReturnType)) {
    if (isStatic(domainMethod)) {
      poison("Method %s.%s is an instance method, " + "while the corresponding method on %s is static",method.getEnclosingType().getName(),method.getName(),serviceClass.getName());
      return false;
    }
    JClassType[] params=ModelUtils.findParameterizationOf(instanceRequestInterface,requestReturnType);
    methodBuilder.setInstanceType(getEntityProxyType(params[0]));
    invocationReturnType=params[1];
  }
 else   if (requestInterface.isAssignableFrom(requestReturnType)) {
    if (!isStatic(domainMethod)) {
      poison("Method %s.%s is a static method, " + "while the corresponding method on %s is not",method.getEnclosingType().getName(),method.getName(),serviceClass.getName());
      return false;
    }
    JClassType[] params=ModelUtils.findParameterizationOf(requestInterface,requestReturnType);
    invocationReturnType=params[0];
  }
 else {
    poison(badContextReturnType(method,requestInterface,instanceRequestInterface));
    return false;
  }
  boolean paramsOk=true;
  JParameter[] params=method.getParameters();
  Class<?>[] domainParams=domainMethod.getParameterTypes();
  if (params.length != domainParams.length) {
    poison("Method %s.%s parameters do not match same method on %s",method.getEnclosingType().getName(),method.getName(),serviceClass.getName());
  }
  for (int i=0; i < params.length; ++i) {
    JParameter param=params[i];
    Class<?> domainParam=domainParams[i];
    paramsOk=validateTransportableType(new RequestMethod.Builder(),param.getType(),false) && paramsOk;
    paramsOk=validateProxyAndDomainTypeEquals(param.getType(),domainParam,i,methodLocation(method),methodLocation(domainMethod)) && paramsOk;
  }
  return validateTransportableType(methodBuilder,invocationReturnType,true) && validateProxyAndDomainTypeEquals(invocationReturnType,domainMethod.getReturnType(),-1,methodLocation(method),methodLocation(domainMethod)) && paramsOk;
}
