{
  JMethod method=x.getTarget();
  JsInvocation jsInvocation=new JsInvocation(x.getSourceInfo());
  popList(jsInvocation.getArguments(),x.getArgs().size());
  if (JProgram.isClinit(method)) {
    JDeclaredType type=method.getEnclosingType();
    JDeclaredType clinitTarget=type.getClinitTarget();
    if (clinitTarget == null || program.isJsTypePrototype(clinitTarget)) {
      if (x.getInstance() != null) {
        pop();
      }
      push(JsNullLiteral.INSTANCE);
      return;
    }
 else     if (type != clinitTarget) {
      method=clinitTarget.getClinitMethod();
    }
  }
  JsNameRef qualifier=null;
  JsExpression unnecessaryQualifier=null;
  JsExpression result=null;
  boolean isJsProperty=false;
  boolean isSam=false;
  result=jsInvocation;
  if (method.isStatic()) {
    if (x.getInstance() != null) {
      unnecessaryQualifier=pop();
    }
    qualifier=names.get(method).makeRef(x.getSourceInfo());
  }
 else   if (x.isStaticDispatchOnly() && method.isConstructor()) {
    JsName callName=objectScope.declareName("call");
    callName.setObfuscatable(false);
    qualifier=callName.makeRef(x.getSourceInfo());
    JsNameRef methodRef=names.get(method).makeRef(x.getSourceInfo());
    qualifier.setQualifier(methodRef);
    jsInvocation.getArguments().add(0,(JsExpression)pop());
    if (program.isJsTypePrototype(method.getEnclosingType())) {
      result=dispatchToSuperPrototype(x,method,qualifier,methodRef,jsInvocation);
    }
  }
 else   if (x.isStaticDispatchOnly() && !method.isConstructor()) {
    final JDeclaredType superMethodTargetType=method.getEnclosingType();
    JsInvocation getPrototypeCall=constructInvocation(x.getSourceInfo(),"JavaClassHierarchySetupUtil.getClassPrototype",convertJavaLiteral(typeMapper.get(superMethodTargetType)));
    JsNameRef methodNameRef=polymorphicNames.get(method).makeRef(x.getSourceInfo());
    methodNameRef.setQualifier(getPrototypeCall);
    JsName callName=objectScope.declareName("call");
    callName.setObfuscatable(false);
    qualifier=callName.makeRef(x.getSourceInfo());
    qualifier.setQualifier(methodNameRef);
    jsInvocation.getArguments().add(0,(JsExpression)pop());
    if (program.isJsTypePrototype(method.getEnclosingType())) {
      result=dispatchToSuperPrototype(x,method,qualifier,methodNameRef,jsInvocation);
    }
    methodsForJsInlining.add(currentMethod);
  }
 else {
    JsName polyName=polymorphicNames.get(method);
    isJsProperty=method.isOrOverridesJsProperty();
    isSam=method.isOrOverridesJsFunctionMethod();
    if (isJsProperty) {
      JsExpression qualExpr=pop();
switch (method.getImmediateOrTransitiveJsPropertyType()) {
case GET:
        result=createGetterDispatch(x,unnecessaryQualifier,method,qualExpr);
      break;
case SET:
    result=createSetterDispatch(x,jsInvocation,method,qualExpr);
  break;
default :
throw new InternalCompilerException("JsProperty not a setter or getter.");
}
}
 else if (isSam) {
JsExpression qualExpr=pop();
result=createSAMcallDispatch(x,jsInvocation,qualExpr);
}
 else {
if (typeOracle.needsJsInteropBridgeMethod(method)) {
maybeDispatchViaTrampolineToBridgeMethod(x,method,jsInvocation,unnecessaryQualifier,result,polyName);
return;
}
 else {
qualifier=polyName.makeRef(x.getSourceInfo());
qualifier.setQualifier((JsExpression)pop());
}
}
}
if (!isJsProperty && !isSam) {
jsInvocation.setQualifier(qualifier);
}
push(createCommaExpression(unnecessaryQualifier,result));
}
