{
  SourceInfo sourceInfo=x.getSourceInfo();
  if (x != program.getTypeJavaLangString()) {
    JsInvocation defineClass=new JsInvocation(x.getSourceInfo());
    JsName defineClassRef=indexedFunctions.get("JavaClassHierarchySetupUtil.defineClass").getName();
    defineClass.setQualifier(defineClassRef.makeRef(x.getSourceInfo()));
    JLiteral typeId=getRuntimeTypeReference(x);
    JClassType superClass=x.getSuperClass();
    JLiteral superTypeId=(superClass == null) ? JNullLiteral.INSTANCE : getRuntimeTypeReference(x.getSuperClass());
    defineClass.getArguments().add(convertJavaLiteral(typeId));
    defineClass.getArguments().add(convertJavaLiteral(superTypeId));
    JsExpression castMap=generateCastableTypeMap(x);
    defineClass.getArguments().add(castMap);
    for (    JMethod method : x.getMethods()) {
      if (liveCtors.contains(method)) {
        defineClass.getArguments().add(names.get(method).makeRef(sourceInfo));
      }
    }
    JsStatement tmpAsgStmt=defineClass.makeStmt();
    globalStmts.add(tmpAsgStmt);
    typeForStatMap.put(tmpAsgStmt,x);
  }
 else {
    JsNameRef rhs=prototype.makeRef(sourceInfo);
    rhs.setQualifier(JsRootScope.INSTANCE.findExistingUnobfuscatableName("String").makeRef(sourceInfo));
    JsExpression tmpAsg=createAssignment(globalTemp.makeRef(sourceInfo),rhs);
    JsExprStmt tmpAsgStmt=tmpAsg.makeStmt();
    globalStmts.add(tmpAsgStmt);
    typeForStatMap.put(tmpAsgStmt,x);
    JField castableTypeMapField=program.getIndexedField("Cast.stringCastMap");
    JsName castableTypeMapName=names.get(castableTypeMapField);
    JsNameRef ctmRef=castableTypeMapName.makeRef(sourceInfo);
    JsExpression castMapLit=generateCastableTypeMap(x);
    JsExpression ctmAsg=createAssignment(ctmRef,castMapLit);
    JsExprStmt ctmAsgStmt=ctmAsg.makeStmt();
    globalStmts.add(ctmAsgStmt);
  }
}
