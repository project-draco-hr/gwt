{
  if (JavaScriptHost.class.getName().equals(className)) {
    return javaScriptHostBytes;
  }
  if (classRewriter != null && classRewriter.isJsoIntf(className)) {
    return classRewriter.writeJsoIntf(className);
  }
  String lookupClassName=canonicalizeClassName(className);
  CompiledClass compiledClass=compilationState.getClassFileMap().get(lookupClassName);
  CompilationUnit unit=(compiledClass == null) ? getUnitForClassName(className) : compiledClass.getUnit();
  if (emmaAvailable) {
    List<JsniMethod> jsniMethods=(unit == null) ? null : unit.getJsniMethods();
    if (unit != null && !unit.isSuperSource() && unit.hasAnonymousClasses() && jsniMethods != null && jsniMethods.size() > 0 && !unit.createdClassMapping()) {
      String mainLookupClassName=unit.getTypeName().replace('.','/');
      byte mainClassBytes[]=emmaStrategy.getEmmaClassBytes(null,mainLookupClassName,0);
      if (mainClassBytes != null) {
        if (!unit.constructAnonymousClassMappings(mainClassBytes)) {
          logger.log(TreeLogger.ERROR,"Our heuristic for mapping anonymous classes between compilers " + "failed. Unsafe to continue because the wrong jsni code " + "could end up running. className = "+ className);
          return null;
        }
      }
 else {
        logger.log(TreeLogger.ERROR,"main class bytes is null for unit = " + unit + ", mainLookupClassName = "+ mainLookupClassName);
      }
    }
  }
  byte classBytes[]=null;
  if (compiledClass != null) {
    classBytes=compiledClass.getBytes();
    if (!compiledClass.getUnit().isSuperSource()) {
      classBytes=emmaStrategy.getEmmaClassBytes(classBytes,lookupClassName,compiledClass.getUnit().getLastModified());
    }
 else {
      logger.log(TreeLogger.SPAM,"no emma instrumentation for " + lookupClassName + " because it is from super-source");
    }
  }
 else   if (emmaAvailable) {
    if (typeHasCompilationUnit(className) && isClassnameGenerated(className)) {
      logger.log(TreeLogger.DEBUG,"EmmaStrategy: loading " + lookupClassName + " from disk even though TypeOracle does not know about it");
      classBytes=emmaStrategy.getEmmaClassBytes(null,lookupClassName,0);
    }
  }
  if (classBytes != null && classRewriter != null) {
    Map<String,String> anonymousClassMap=Collections.emptyMap();
    if (unit != null) {
      anonymousClassMap=unit.getAnonymousClassMap();
    }
    byte[] newBytes=classRewriter.rewrite(className,classBytes,anonymousClassMap);
    if (CLASS_DUMP) {
      if (!Arrays.equals(classBytes,newBytes)) {
        classDump(className,newBytes);
      }
    }
    classBytes=newBytes;
  }
  return classBytes;
}
