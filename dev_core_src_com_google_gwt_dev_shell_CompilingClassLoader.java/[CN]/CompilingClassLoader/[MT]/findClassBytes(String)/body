{
  if (JavaScriptHost.class.getName().equals(className)) {
    return javaScriptHostBytes;
  }
  if (classRewriter != null && classRewriter.isJsoIntf(className)) {
    return classRewriter.writeJsoIntf(className);
  }
  String lookupClassName=className.replace('.','/');
  if (classRewriter != null && classRewriter.isJsoImpl(className)) {
    lookupClassName=lookupClassName.substring(0,lookupClassName.length() - 1);
  }
  CompiledClass compiledClass=compilationState.getClassFileMap().get(lookupClassName);
  CompilationUnit unit=(compiledClass == null) ? getUnitForClassName(lookupClassName) : compiledClass.getUnit();
  if (emmaAvailable) {
    List<JsniMethod> jsniMethods=(unit == null) ? null : unit.getJsniMethods();
    if (unit != null && !unit.isSuperSource() && !unit.isGenerated() && unit.hasAnonymousClasses() && jsniMethods != null && jsniMethods.size() > 0 && !unit.createdClassMapping()) {
      if (!unit.constructAnonymousClassMappings(logger)) {
        logger.log(TreeLogger.ERROR,"Our heuristic for mapping anonymous classes between compilers " + "failed. Unsafe to continue because the wrong jsni code " + "could end up running. className = "+ className);
        return null;
      }
    }
  }
  byte classBytes[]=null;
  if (compiledClass != null) {
    classBytes=compiledClass.getBytes();
    if (!compiledClass.getUnit().isSuperSource()) {
      classBytes=emmaStrategy.getEmmaClassBytes(classBytes,lookupClassName,compiledClass.getUnit().getLastModified());
    }
 else {
      logger.log(TreeLogger.SPAM,"no emma instrumentation for " + lookupClassName + " because it is from super-source");
    }
  }
 else   if (emmaAvailable) {
    if (typeHasCompilationUnit(lookupClassName) && isClassnameGenerated(className)) {
      logger.log(TreeLogger.DEBUG,"EmmaStrategy: loading " + lookupClassName + " from disk even though TypeOracle does not know about it");
      classBytes=emmaStrategy.getEmmaClassBytes(null,lookupClassName,0);
    }
  }
  if (classBytes != null && classRewriter != null) {
    injectJsniMethods(unit);
    Map<String,String> anonymousClassMap=Collections.emptyMap();
    if (unit != null) {
      anonymousClassMap=unit.getAnonymousClassMap();
    }
    byte[] newBytes=classRewriter.rewrite(className,classBytes,anonymousClassMap);
    if (CLASS_DUMP) {
      if (!Arrays.equals(classBytes,newBytes)) {
        classDump(className,newBytes);
      }
    }
    classBytes=newBytes;
  }
  return classBytes;
}
