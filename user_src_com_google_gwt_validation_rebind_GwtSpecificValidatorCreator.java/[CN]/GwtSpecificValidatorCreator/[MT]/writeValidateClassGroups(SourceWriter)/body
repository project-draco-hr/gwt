{
  sw.println("public <T> void validateClassGroups(");
  sw.indent();
  sw.indent();
  sw.println("GwtValidationContext<T> context,");
  sw.println(beanHelper.getTypeCanonicalName() + " object,");
  sw.println("Set<ConstraintViolation<T>> violations,");
  sw.println("Class<?>... groups) {");
  sw.outdent();
  Set<PropertyDescriptor> properties=beanHelper.getBeanDescriptor().getConstrainedProperties();
  for (  PropertyDescriptor p : properties) {
    writeValidatePropertyCall(sw,p,false,true);
  }
  int count=0;
  Class<?> clazz=beanHelper.getClazz();
  for (  ConstraintDescriptor<?> constraint : beanHelper.getBeanDescriptor().getConstraintDescriptors()) {
    if (hasMatchingAnnotation(constraint)) {
      if (!constraint.getConstraintValidatorClasses().isEmpty()) {
        Class<? extends ConstraintValidator<? extends Annotation,?>> validatorClass=getValidatorForType(constraint,clazz);
        sw.print("validate(context, violations, null, object, ");
        sw.print("new ");
        sw.print(validatorClass.getCanonicalName());
        sw.print("(), ");
        sw.print(constraintDescriptorVar("this",count));
        sw.println(", groups);");
      }
 else       if (constraint.getComposingConstraints().isEmpty()) {
        logger.log(TreeLogger.WARN,"No ConstraintValidator of " + constraint + " for type "+ clazz);
      }
    }
    count++;
  }
  writeValidateInheritance(sw,clazz,Stage.OBJECT,null);
  sw.outdent();
  sw.println("}");
}
