{
  JClassType propertyType=typeOracle.findType(Property.class.getName());
  final JClassType localTakesValueType=typeOracle.findType(TakesValue.class.getName());
  final JClassType localHasTextType=typeOracle.findType(HasText.class.getName());
  Map<String,JField> recordFieldNames=getAccessiblePropertyFields(recordType);
  Map<JField,JClassType> localUiPropertyFields=new HashMap<JField,JClassType>();
  for (  final JField uiField : viewType.getFields()) {
    JField recordField=recordFieldNames.get(uiField.getName());
    if (uiField.getAnnotation(UiField.class) == null || recordField == null) {
      continue;
    }
    JParameterizedType parameterizedField=recordField.getType().isClass().isParameterized();
    if (parameterizedField == null || parameterizedField.getBaseType() != propertyType || parameterizedField.getTypeArgs().length != 1) {
      logger.log(TreeLogger.ERROR,"A property type must have exactly one type argument");
      throw new UnableToCompleteException();
    }
    final JClassType fieldTypeArg=parameterizedField.getTypeArgs()[0];
    JClassType takesValueSuperInterface=getSuperInterface(uiField,new Matcher(){
      public boolean matches(      JClassType classType) throws UnableToCompleteException {
        JParameterizedType parameterizedType=classType.isParameterized();
        if (parameterizedType == null || parameterizedType.getBaseType() != localTakesValueType || parameterizedType.getTypeArgs().length != 1) {
          return false;
        }
        JClassType typeArg=parameterizedType.getTypeArgs()[0];
        if (typeArg != fieldTypeArg) {
          logger.log(TreeLogger.ERROR,"The type of value " + typeArg.getName() + " UiField "+ uiField+ " can receive does not match the type of property "+ fieldTypeArg.getName());
          throw new UnableToCompleteException();
        }
        return true;
      }
    }
,logger);
    if (takesValueSuperInterface != null) {
      localUiPropertyFields.put(uiField,takesValueSuperInterface);
    }
 else {
      JClassType hasTextSuperInterface=getSuperInterface(uiField,new Matcher(){
        public boolean matches(        JClassType classType){
          return classType == localHasTextType;
        }
      }
,logger);
      if (hasTextSuperInterface != null) {
        localUiPropertyFields.put(uiField,hasTextSuperInterface);
      }
 else {
        logger.log(TreeLogger.ERROR,"The UiField " + uiField + " does not have a HaxText or HasValue super-interface");
        throw new UnableToCompleteException();
      }
    }
  }
  return localUiPropertyFields;
}
