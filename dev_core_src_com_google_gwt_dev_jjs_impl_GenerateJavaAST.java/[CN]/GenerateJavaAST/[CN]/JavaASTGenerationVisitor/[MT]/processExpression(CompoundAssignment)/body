{
  JBinaryOperator op;
switch (x.operator) {
case CompoundAssignment.PLUS:
    op=JBinaryOperator.ASG_ADD;
  break;
case CompoundAssignment.MINUS:
op=JBinaryOperator.ASG_SUB;
break;
case CompoundAssignment.MULTIPLY:
op=JBinaryOperator.ASG_MUL;
break;
case CompoundAssignment.DIVIDE:
op=JBinaryOperator.ASG_DIV;
break;
case CompoundAssignment.AND:
op=JBinaryOperator.ASG_BIT_AND;
break;
case CompoundAssignment.OR:
op=JBinaryOperator.ASG_BIT_OR;
break;
case CompoundAssignment.XOR:
op=JBinaryOperator.ASG_BIT_XOR;
break;
case CompoundAssignment.REMAINDER:
op=JBinaryOperator.ASG_MOD;
break;
case CompoundAssignment.LEFT_SHIFT:
op=JBinaryOperator.ASG_SHL;
break;
case CompoundAssignment.RIGHT_SHIFT:
op=JBinaryOperator.ASG_SHR;
break;
case CompoundAssignment.UNSIGNED_RIGHT_SHIFT:
op=JBinaryOperator.ASG_SHRU;
break;
default :
throw new InternalCompilerException("Unexpected operator for CompoundAssignment");
}
JType type=(JType)typeMap.get(x.resolvedType);
SourceInfo info=makeSourceInfo(x);
return processBinaryOperation(info,op,type,x.lhs,x.expression);
}
