{
  JBinaryOperator op;
switch (x.operator) {
case OperatorIds.PLUS:
    if (program.isJavaLangString((JType)typeMap.get(x.resolvedType))) {
      op=JBinaryOperator.ASG_CONCAT;
    }
 else {
      op=JBinaryOperator.ASG_ADD;
    }
  break;
case OperatorIds.MINUS:
op=JBinaryOperator.ASG_SUB;
break;
case OperatorIds.MULTIPLY:
op=JBinaryOperator.ASG_MUL;
break;
case OperatorIds.DIVIDE:
op=JBinaryOperator.ASG_DIV;
break;
case OperatorIds.AND:
op=JBinaryOperator.ASG_BIT_AND;
break;
case OperatorIds.OR:
op=JBinaryOperator.ASG_BIT_OR;
break;
case OperatorIds.XOR:
op=JBinaryOperator.ASG_BIT_XOR;
break;
case OperatorIds.REMAINDER:
op=JBinaryOperator.ASG_MOD;
break;
case OperatorIds.LEFT_SHIFT:
op=JBinaryOperator.ASG_SHL;
break;
case OperatorIds.RIGHT_SHIFT:
op=JBinaryOperator.ASG_SHR;
break;
case CompoundAssignment.UNSIGNED_RIGHT_SHIFT:
op=JBinaryOperator.ASG_SHRU;
break;
default :
throw new InternalCompilerException("Unexpected operator for CompoundAssignment");
}
JType type=(JType)typeMap.get(x.resolvedType);
SourceInfo info=makeSourceInfo(x);
return processBinaryOperation(info,op,type,x.lhs,x.expression);
}
