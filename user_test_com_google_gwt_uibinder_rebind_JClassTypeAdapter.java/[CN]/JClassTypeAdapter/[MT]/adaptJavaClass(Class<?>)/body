{
  if (clazz.isPrimitive()) {
    throw new RuntimeException("Only classes can be passed to adaptJavaClass");
  }
  JClassType type=adaptedClasses.get(clazz);
  if (type != null) {
    return type;
  }
  type=createMock(JClassType.class);
  final JClassType finalType=type;
  adaptedClasses.put(clazz,type);
  addAnnotationBehaviour(clazz,type);
  when(type.getMethods()).thenAnswer(new Answer<JMethod[]>(){
    @Override public JMethod[] answer(    InvocationOnMock invocation) throws Throwable {
      Method[] realMethods=clazz.getDeclaredMethods();
      JMethod[] methods=new JMethod[realMethods.length];
      for (int i=0; i < realMethods.length; i++) {
        methods[i]=adaptMethod(realMethods[i],finalType);
      }
      return methods;
    }
  }
);
  when(type.getConstructors()).thenAnswer(new Answer<JConstructor[]>(){
    @Override public JConstructor[] answer(    InvocationOnMock invocation) throws Throwable {
      Constructor<?>[] realConstructors=clazz.getDeclaredConstructors();
      JConstructor[] constructors=new JConstructor[realConstructors.length];
      for (int i=0; i < realConstructors.length; i++) {
        constructors[i]=adaptConstructor(realConstructors[i],finalType);
      }
      return constructors;
    }
  }
);
  when(type.getFields()).thenAnswer(new Answer<JField[]>(){
    @Override public JField[] answer(    InvocationOnMock invocation) throws Throwable {
      Field[] realFields=clazz.getDeclaredFields();
      JField[] fields=new JField[realFields.length];
      for (int i=0; i < realFields.length; i++) {
        fields[i]=adaptField(realFields[i],finalType);
      }
      return fields;
    }
  }
);
  when(type.getName()).thenReturn(clazz.getName());
  when(type.getQualifiedSourceName()).thenReturn(clazz.getCanonicalName());
  when(type.getSimpleSourceName()).thenReturn(clazz.getSimpleName());
  int modifiers=clazz.getModifiers();
  when(type.isAbstract()).thenReturn(Modifier.isAbstract(modifiers));
  when(type.isFinal()).thenReturn(Modifier.isFinal(modifiers));
  when(type.isPublic()).thenReturn(Modifier.isPublic(modifiers));
  when(type.isProtected()).thenReturn(Modifier.isProtected(modifiers));
  when(type.isPrivate()).thenReturn(Modifier.isPrivate(modifiers));
  when(type.isArray()).thenReturn(null);
  when(type.isEnum()).thenReturn(null);
  when(type.isPrimitive()).thenReturn(null);
  when(type.isClassOrInterface()).thenReturn(type);
  if (clazz.isInterface()) {
    when(type.isClass()).thenReturn(null);
    when(type.isInterface()).thenReturn(type);
  }
 else {
    when(type.isClass()).thenReturn(type);
    when(type.isInterface()).thenReturn(null);
  }
  when(type.getEnclosingType()).thenAnswer(new Answer<JClassType>(){
    @Override public JClassType answer(    InvocationOnMock invocation) throws Throwable {
      Class<?> enclosingClass=clazz.getEnclosingClass();
      if (enclosingClass == null) {
        return null;
      }
      return adaptJavaClass(enclosingClass);
    }
  }
);
  when(type.getSuperclass()).thenAnswer(new Answer<JClassType>(){
    @Override public JClassType answer(    InvocationOnMock invocation) throws Throwable {
      Class<?> superclass=clazz.getSuperclass();
      if (superclass == null) {
        return null;
      }
      return adaptJavaClass(superclass);
    }
  }
);
  return type;
}
