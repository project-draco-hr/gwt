{
  if (iMethods == null) {
    this.methods=this.bridgeMethods=Binding.NO_METHODS;
    return;
  }
  ArrayList<MethodBinding> methodBindings=new ArrayList<MethodBinding>(iMethods.length);
  ArrayList<MethodBinding> bridgeBindings=new ArrayList<MethodBinding>(iMethods.length);
  boolean isViewedAsDeprecated=isViewedAsDeprecated();
  boolean hasRestrictedAccess=hasRestrictedAccess();
  boolean discardedClinit=false;
  for (int i=0; i < iMethods.length; ++i) {
    IBinaryMethod method=iMethods[i];
    boolean isBridge=(method.getModifiers() & ClassFileConstants.AccBridge) != 0;
    if (!isBridge && (method.getModifiers() & ClassFileConstants.AccSynthetic) != 0) {
      continue;
    }
    if (!discardedClinit) {
      char[] methodName=method.getSelector();
      if (methodName.length == 8 && methodName[0] == '<') {
        discardedClinit=true;
        continue;
      }
    }
    MethodBinding newMethod=createMethod(iMethods[i],sourceLevel,missingTypeNames);
    if (isViewedAsDeprecated && !newMethod.isDeprecated())     newMethod.modifiers|=ExtraCompilerModifiers.AccDeprecatedImplicitly;
    if (hasRestrictedAccess)     newMethod.modifiers|=ExtraCompilerModifiers.AccRestrictedAccess;
    if (isBridge)     bridgeBindings.add(newMethod);
 else     methodBindings.add(newMethod);
  }
  if (sourceLevel < ClassFileConstants.JDK1_5 && this.environment.globalOptions.complianceLevel >= ClassFileConstants.JDK1_5)   methodBindings.addAll(bridgeBindings);
  this.methods=methodBindings.size() == 0 ? Binding.NO_METHODS : methodBindings.toArray(new MethodBinding[methodBindings.size()]);
  this.bridgeMethods=bridgeBindings.size() == 0 ? Binding.NO_METHODS : bridgeBindings.toArray(new MethodBinding[bridgeBindings.size()]);
}
