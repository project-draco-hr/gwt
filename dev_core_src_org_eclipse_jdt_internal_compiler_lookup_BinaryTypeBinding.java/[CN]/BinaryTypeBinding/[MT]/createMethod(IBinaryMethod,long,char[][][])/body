{
  int methodModifiers=method.getModifiers() | ExtraCompilerModifiers.AccUnresolved;
  if (sourceLevel < ClassFileConstants.JDK1_5)   methodModifiers&=~ClassFileConstants.AccVarargs;
  ReferenceBinding[] exceptions=Binding.NO_EXCEPTIONS;
  TypeBinding[] parameters=Binding.NO_PARAMETERS;
  TypeVariableBinding[] typeVars=Binding.NO_TYPE_VARIABLES;
  AnnotationBinding[][] paramAnnotations=null;
  TypeBinding returnType=null;
  final boolean use15specifics=sourceLevel >= ClassFileConstants.JDK1_5;
  char[] methodSignature=use15specifics ? method.getGenericSignature() : null;
  if (methodSignature == null) {
    char[] methodDescriptor=method.getMethodDescriptor();
    int numOfParams=0;
    char nextChar;
    int index=0;
    while ((nextChar=methodDescriptor[++index]) != ')') {
      if (nextChar != '[') {
        numOfParams++;
        if (nextChar == 'L')         while ((nextChar=methodDescriptor[++index]) != ';') {
        }
      }
    }
    int startIndex=(method.isConstructor() && isMemberType() && !isStatic()) ? 1 : 0;
    int size=numOfParams - startIndex;
    if (size > 0) {
      parameters=new TypeBinding[size];
      if (this.environment.globalOptions.storeAnnotations)       paramAnnotations=new AnnotationBinding[size][];
      index=1;
      int end=0;
      for (int i=0; i < numOfParams; i++) {
        while ((nextChar=methodDescriptor[++end]) == '[') {
        }
        if (nextChar == 'L')         while ((nextChar=methodDescriptor[++end]) != ';') {
        }
        if (i >= startIndex) {
          parameters[i - startIndex]=environment.getTypeFromSignature(methodDescriptor,index,end,false,this,missingTypeNames);
          if (paramAnnotations != null)           paramAnnotations[i - startIndex]=createAnnotations(method.getParameterAnnotations(i),this.environment,missingTypeNames);
        }
        index=end + 1;
      }
    }
    char[][] exceptionTypes=method.getExceptionTypeNames();
    if (exceptionTypes != null) {
      size=exceptionTypes.length;
      if (size > 0) {
        exceptions=new ReferenceBinding[size];
        for (int i=0; i < size; i++)         exceptions[i]=environment.getTypeFromConstantPoolName(exceptionTypes[i],0,-1,false,missingTypeNames);
      }
    }
    if (!method.isConstructor())     returnType=environment.getTypeFromSignature(methodDescriptor,index + 1,-1,false,this,missingTypeNames);
  }
 else {
    methodModifiers|=ExtraCompilerModifiers.AccGenericSignature;
    SignatureWrapper wrapper=new SignatureWrapper(methodSignature);
    if (wrapper.signature[wrapper.start] == '<') {
      wrapper.start++;
      typeVars=createTypeVariables(wrapper,false,missingTypeNames);
      wrapper.start++;
    }
    if (wrapper.signature[wrapper.start] == '(') {
      wrapper.start++;
      if (wrapper.signature[wrapper.start] == ')') {
        wrapper.start++;
      }
 else {
        java.util.ArrayList types=new java.util.ArrayList(2);
        while (wrapper.signature[wrapper.start] != ')')         types.add(environment.getTypeFromTypeSignature(wrapper,typeVars,this,missingTypeNames));
        wrapper.start++;
        int numParam=types.size();
        parameters=new TypeBinding[numParam];
        types.toArray(parameters);
        if (this.environment.globalOptions.storeAnnotations) {
          paramAnnotations=new AnnotationBinding[numParam][];
          for (int i=0; i < numParam; i++)           paramAnnotations[i]=createAnnotations(method.getParameterAnnotations(i),this.environment,missingTypeNames);
        }
      }
    }
    returnType=environment.getTypeFromTypeSignature(wrapper,typeVars,this,missingTypeNames);
    if (!wrapper.atEnd() && wrapper.signature[wrapper.start] == '^') {
      java.util.ArrayList types=new java.util.ArrayList(2);
      do {
        wrapper.start++;
        types.add(environment.getTypeFromTypeSignature(wrapper,typeVars,this,missingTypeNames));
      }
 while (!wrapper.atEnd() && wrapper.signature[wrapper.start] == '^');
      exceptions=new ReferenceBinding[types.size()];
      types.toArray(exceptions);
    }
 else {
      char[][] exceptionTypes=method.getExceptionTypeNames();
      if (exceptionTypes != null) {
        int size=exceptionTypes.length;
        if (size > 0) {
          exceptions=new ReferenceBinding[size];
          for (int i=0; i < size; i++)           exceptions[i]=environment.getTypeFromConstantPoolName(exceptionTypes[i],0,-1,false,missingTypeNames);
        }
      }
    }
  }
  MethodBinding result=method.isConstructor() ? new MethodBinding(methodModifiers,parameters,exceptions,this) : new MethodBinding(methodModifiers,method.getSelector(),returnType,parameters,exceptions,this);
  if (this.environment.globalOptions.storeAnnotations)   result.setAnnotations(createAnnotations(method.getAnnotations(),this.environment,missingTypeNames),paramAnnotations,isAnnotationType() ? convertMemberValue(method.getDefaultValue(),this.environment,missingTypeNames) : null);
  if (use15specifics)   result.tagBits|=method.getTagBits();
  result.typeVariables=typeVars;
  for (int i=0, length=typeVars.length; i < length; i++)   typeVars[i].declaringElement=result;
  return result;
}
