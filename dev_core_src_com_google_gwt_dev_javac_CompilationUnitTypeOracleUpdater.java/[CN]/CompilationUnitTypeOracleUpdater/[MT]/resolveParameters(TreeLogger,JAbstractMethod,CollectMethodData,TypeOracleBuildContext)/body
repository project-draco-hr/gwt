{
  Type[] argTypes=methodData.getArgTypes();
  boolean argNamesAreReal=methodData.hasActualArgNames();
  String[] argNames=methodData.getArgNames();
  if (!argNamesAreReal) {
    String[] lookupNames=context.allMethodArgs.lookup(method,methodData);
    if (lookupNames != null) {
      argNames=lookupNames;
      argNamesAreReal=true;
    }
  }
  List<CollectAnnotationData>[] paramAnnot=methodData.getArgAnnotations();
  for (int i=0; i < argTypes.length; ++i) {
    Type argType=argTypes[i];
    JType argJType=resolveType(argType);
    if (argJType == null) {
      logger.log(TreeLogger.ERROR,"Unable to resolve type " + argType.getInternalName() + " of argument "+ methodData.getArgNames()[i]);
      return false;
    }
    Map<Class<? extends Annotation>,Annotation> declaredAnnotations=Maps.newHashMap();
    resolveAnnotations(logger,paramAnnot[i],declaredAnnotations);
    newParameter(method,argJType,argNames[i],declaredAnnotations,argNamesAreReal);
  }
  return true;
}
