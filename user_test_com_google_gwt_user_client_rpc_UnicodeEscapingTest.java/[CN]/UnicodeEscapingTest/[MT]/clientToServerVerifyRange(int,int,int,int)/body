{
  current=start;
  int blockEnd=Math.min(end,current + size);
  getService().verifyStringContainingCharacterRange(current,blockEnd,getStringContainingCharacterRange(start,blockEnd),new AsyncCallback<Boolean>(){
    List<Throwable> fails=new ArrayList<Throwable>();
    @Override public void onFailure(    Throwable caught){
      fails.add(caught);
      onSuccess(false);
    }
    @Override public void onSuccess(    Boolean ignored){
      current+=step;
      if (current < end) {
        delayTestFinish(TEST_FINISH_DELAY_MS);
        int blockEnd=Math.min(end,current + size);
        try {
          getService().verifyStringContainingCharacterRange(current,blockEnd,getStringContainingCharacterRange(current,blockEnd),this);
        }
 catch (        InvalidCharacterException e) {
          fails.add(e);
        }
      }
 else       if (!fails.isEmpty()) {
        StringBuilder msg=new StringBuilder();
        for (        Throwable t : fails) {
          msg.append(t.getMessage()).append("\n");
        }
        TestSetValidator.rethrowException(new RuntimeException(msg.toString()));
      }
 else {
        finishTest();
      }
    }
  }
);
}
