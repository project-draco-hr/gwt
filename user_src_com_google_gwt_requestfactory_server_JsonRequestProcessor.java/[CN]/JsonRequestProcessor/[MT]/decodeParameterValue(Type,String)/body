{
  Class<?> parameterType=null;
  if (genericParameterType instanceof Class) {
    parameterType=(Class<?>)genericParameterType;
  }
  if (genericParameterType instanceof ParameterizedType) {
    ParameterizedType pType=(ParameterizedType)genericParameterType;
    if (PropertyReference.class == pType.getRawType()) {
      parameterType=(Class<?>)pType.getActualTypeArguments()[0];
    }
  }
  if (String.class == parameterType) {
    return parameterValue;
  }
  if (Boolean.class == parameterType || boolean.class == parameterType) {
    return Boolean.valueOf(parameterValue);
  }
  if (Integer.class == parameterType || int.class == parameterType) {
    return new Integer(parameterValue);
  }
  if (Byte.class == parameterType || byte.class == parameterType) {
    return new Byte(parameterValue);
  }
  if (Short.class == parameterType || short.class == parameterType) {
    return new Short(parameterValue);
  }
  if (Float.class == parameterType || float.class == parameterType) {
    return new Float(parameterValue);
  }
  if (Double.class == parameterType || double.class == parameterType) {
    return new Double(parameterValue);
  }
  if (Long.class == parameterType || long.class == parameterType) {
    return new Long(parameterValue);
  }
  if (Character.class == parameterType || char.class == parameterType) {
    return parameterValue.charAt(0);
  }
  if (BigInteger.class == parameterType) {
    return new BigInteger(parameterValue);
  }
  if (BigDecimal.class == parameterType) {
    return new BigDecimal(parameterValue);
  }
  if (parameterType.isEnum()) {
    try {
      int ordinal=Integer.parseInt(parameterValue);
      Method valuesMethod=parameterType.getDeclaredMethod("values",new Class[0]);
      log.severe("Type is " + parameterType + " valuesMethod "+ valuesMethod);
      if (valuesMethod != null) {
        valuesMethod.setAccessible(true);
        Enum<?>[] values=(Enum<?>[])valuesMethod.invoke(null);
        for (        Enum<?> e : values) {
          if (ordinal == e.ordinal()) {
            return e;
          }
        }
      }
      throw new IllegalArgumentException("Can't decode enum " + parameterType + " no matching ordinal "+ ordinal);
    }
 catch (    NoSuchMethodException e) {
      throw new IllegalArgumentException("Can't decode enum " + parameterType);
    }
catch (    InvocationTargetException e) {
      throw new IllegalArgumentException("Can't decode enum " + parameterType);
    }
catch (    IllegalAccessException e) {
      throw new IllegalArgumentException("Can't decode enum " + parameterType);
    }
  }
  if (Date.class == parameterType) {
    return new Date(Long.parseLong(parameterValue));
  }
  if (Record.class.isAssignableFrom(parameterType)) {
    DataTransferObject service=parameterType.getAnnotation(DataTransferObject.class);
    if (service != null) {
      Class<?> sClass=service.value();
      String schemaAndId[]=parameterValue.toString().split("-",3);
      String findMeth=null;
      try {
        findMeth=getMethodNameFromPropertyName(sClass.getSimpleName(),"find");
        Method meth=sClass.getMethod(findMeth,Long.class);
        return meth.invoke(null,Long.valueOf(schemaAndId[0]));
      }
 catch (      NoSuchMethodException e) {
        e.printStackTrace();
        throw new IllegalArgumentException(sClass + " no method named " + findMeth);
      }
catch (      InvocationTargetException e) {
        e.printStackTrace();
        throw new IllegalArgumentException(sClass + " can't invoke method named " + findMeth);
      }
catch (      IllegalAccessException e) {
        e.printStackTrace();
        throw new IllegalArgumentException(sClass + " can't access method named " + findMeth);
      }
    }
  }
  throw new IllegalArgumentException("Unknown parameter type: " + parameterType);
}
