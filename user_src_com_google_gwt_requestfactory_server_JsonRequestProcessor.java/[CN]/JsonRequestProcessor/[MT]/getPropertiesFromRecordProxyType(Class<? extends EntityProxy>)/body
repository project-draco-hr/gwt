{
  if (!EntityProxy.class.isAssignableFrom(record)) {
    return Collections.emptyMap();
  }
  Map<String,Property<?>> properties=new LinkedHashMap<String,Property<?>>();
  Method[] methods=record.getMethods();
  for (  Method method : methods) {
    String methodName=method.getName();
    String propertyName=null;
    Property newProperty=null;
    if (methodName.startsWith("get")) {
      propertyName=Introspector.decapitalize(methodName.substring(3));
      if (propertyName.length() == 0) {
        continue;
      }
      newProperty=getPropertyFromGenericType(propertyName,method.getGenericReturnType());
    }
 else     if (methodName.startsWith("set")) {
      propertyName=Introspector.decapitalize(methodName.substring(3));
      if (propertyName.length() > 0) {
        Type[] parameterTypes=method.getGenericParameterTypes();
        if (parameterTypes.length > 0) {
          newProperty=getPropertyFromGenericType(propertyName,parameterTypes[parameterTypes.length - 1]);
        }
      }
    }
    if (newProperty == null) {
      continue;
    }
    Property existing=properties.put(propertyName,newProperty);
    if (existing != null && !existing.equals(newProperty)) {
      throw new IllegalStateException(String.format("In %s, mismatched getter and setter types for property %s, " + "found %s and %s",record.getName(),propertyName,existing.getName(),newProperty.getName()));
    }
  }
  return properties;
}
