{
  if (!EntityProxy.class.isAssignableFrom(proxyType)) {
    return Collections.emptyMap();
  }
  Map<String,Class<?>> properties=new LinkedHashMap<String,Class<?>>();
  Method[] methods=proxyType.getMethods();
  for (  Method method : methods) {
    String methodName=method.getName();
    Class<?> newType=null;
    String propertyName=null;
    if (methodName.startsWith("get")) {
      propertyName=Introspector.decapitalize(methodName.substring(3));
      if (propertyName.length() == 0) {
        continue;
      }
      newType=method.getReturnType();
    }
 else     if (methodName.startsWith("set")) {
      propertyName=Introspector.decapitalize(methodName.substring(3));
      if (propertyName.length() > 0) {
        Class<?>[] parameterTypes=method.getParameterTypes();
        if (parameterTypes.length > 0) {
          newType=parameterTypes[parameterTypes.length - 1];
        }
      }
    }
    if (newType == null) {
      continue;
    }
    Class<?> existing=properties.put(propertyName,newType);
    if (existing != null && !existing.equals(newType)) {
      throw new IllegalStateException(String.format("In %s, mismatched getter and setter types for property %s, " + "found %s and %s",proxyType.getName(),propertyName,existing.getName(),newType.getName()));
    }
  }
  return properties;
}
