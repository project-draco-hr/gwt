{
  int numFixups=0;
  Queue<JField> potentialClassLiteralFields=new ArrayDeque<JField>(jprogram.getTypeClassLiteralHolder().getFields());
  int numClassLiterals=potentialClassLiteralFields.size();
  while (!potentialClassLiteralFields.isEmpty()) {
    JField field=potentialClassLiteralFields.remove();
    if (!field.isStatic()) {
      continue;
    }
    Fragment classLiteralFragment=fragmentForField.get(field);
    JExpression initializer=field.getInitializer();
    for (    JClassLiteral superclassClassLiteral : classLiteralsIn(initializer)) {
      JField superclassClassLiteralField=superclassClassLiteral.getField();
      Fragment superclassClassLiteralFragment=fragmentForField.get(superclassClassLiteralField);
      if (!fragmentsAreConsistent(classLiteralFragment,superclassClassLiteralFragment)) {
        numFixups++;
        fragmentForField.put(superclassClassLiteralField,NOT_EXCLUSIVE);
        potentialClassLiteralFields.add(superclassClassLiteralField);
      }
    }
  }
  logger.log(TreeLogger.DEBUG,"Fixed up load-order dependencies by moving " + numFixups + " fields in class literal constructors to fragment 0, out of "+ numClassLiterals);
}
