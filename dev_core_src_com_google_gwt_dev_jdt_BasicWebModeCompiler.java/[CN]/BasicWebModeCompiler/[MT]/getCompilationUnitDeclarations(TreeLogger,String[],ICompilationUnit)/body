{
  TypeOracle oracle=compilationState.getTypeOracle();
  Set<? extends JClassType> intfTypes=oracle.getSingleJsoImplInterfaces();
  Map<String,CompiledClass> classMapBySource=compilationState.getClassFileMapBySource();
  Set<CompilationUnit> alreadyAdded=new HashSet<CompilationUnit>();
  List<ICompilationUnit> icus=new ArrayList<ICompilationUnit>(seedTypeNames.length + intfTypes.size() + additionalUnits.length);
  Collections.addAll(icus,additionalUnits);
  for (  String seedTypeName : seedTypeNames) {
    CompilationUnit unit=getUnitForType(logger,classMapBySource,seedTypeName);
    if (unit == null) {
      continue;
    }
    if (alreadyAdded.add(unit)) {
      icus.add(new CompilationUnitAdapter(unit));
    }
 else {
      logger.log(TreeLogger.WARN,"Duplicate compilation unit '" + unit.getDisplayLocation() + "'in seed types");
    }
  }
  for (  JClassType intf : intfTypes) {
    String implName=oracle.getSingleJsoImpl(intf).getQualifiedSourceName();
    CompilationUnit unit=getUnitForType(logger,classMapBySource,implName);
    if (alreadyAdded.add(unit)) {
      icus.add(new CompilationUnitAdapter(unit));
      logger.log(TreeLogger.SPAM,"Forced compilation of unit '" + unit.getDisplayLocation() + "' becasue it contains a SingleJsoImpl type");
    }
  }
  CompilationResults units=compile(logger,icus.toArray(new ICompilationUnit[icus.size()]));
  Memory.maybeDumpMemory("WebModeCompiler");
  return units;
}
