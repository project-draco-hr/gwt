{
  if (nameBasedTypeLocator.resolvedTypeIsAvailable(typeName)) {
    return nameBasedTypeLocator.getResolvedType(typeName);
  }
  if (nameBasedTypeLocator.sourceCompilationUnitIsAvailable(typeName)) {
    assimilateSourceUnit(nameBasedTypeLocator.getCompilationUnitFromSource(typeName),reportErrors);
    return nameBasedTypeLocator.getResolvedType(typeName);
  }
  if (compilerContext.shouldCompileMonolithic()) {
    if (reportErrors) {
      if (nameBasedTypeLocator.hasCompileErrors(typeName)) {
        TreeLogger branch=logger.branch(TreeLogger.ERROR,String.format("Type %s could not be referenced because it previously failed to " + "compile with errors:",typeName));
        nameBasedTypeLocator.logErrorTrace(branch,TreeLogger.ERROR,typeName);
      }
 else {
        logger.log(TreeLogger.ERROR,String.format("Could not find %s in types compiled from source. Is the source glob too strict?",typeName));
      }
      errorsFound=true;
    }
    return null;
  }
  if (nameBasedTypeLocator.libraryCompilationUnitIsAvailable(typeName)) {
    assimilateLibraryUnit(nameBasedTypeLocator.getCompilationUnitFromLibrary(typeName),reportErrors);
    return nameBasedTypeLocator.getResolvedType(typeName);
  }
  if (nameBasedTypeLocator.hasCompileErrors(typeName)) {
    if (reportErrors) {
      TreeLogger branch=logger.branch(TreeLogger.ERROR,String.format("Type %s could not be referenced because it previously failed to compile with errors:",typeName));
      nameBasedTypeLocator.logErrorTrace(branch,TreeLogger.ERROR,typeName);
    }
 else {
      logger.log(TreeLogger.ERROR,String.format("Could not find %s in types compiled from source or in provided dependency libraries. " + "Either the source file was unavailable or there is a missing dependency.",typeName));
    }
    errorsFound=true;
  }
  return null;
}
