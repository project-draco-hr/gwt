{
  for (  JMethod entryMethod : program.getEntryMethods()) {
    flowInto(entryMethod);
  }
  List<String> rootTypeBinaryNames=new ArrayList<String>();
  for (  String rootTypeSourceName : rootTypeSourceNames) {
    JDeclaredType rootType=internalFindType(rootTypeSourceName,sourceNameBasedTypeLocator,true);
    if (rootType == null) {
      continue;
    }
    rootTypeBinaryNames.add(rootType.getName());
    if (jsInteropEnabled && (isJsType(rootType) || hasAnyExports(rootType))) {
      fullFlowIntoType(rootType);
    }
  }
  minimalRebuildCache.setRootTypeNames(rootTypeBinaryNames);
  for (  JClassType type : program.codeGenTypes) {
    for (    JMethod method : type.getMethods()) {
      flowInto(method);
    }
    for (    JField field : type.getFields()) {
      flowInto(field);
    }
  }
  if (incrementalCompile) {
    fullFlowIntoRemainingStaleTypes();
  }
 else   if (isLibraryCompile) {
    Set<String> internalNames=ImmutableSet.copyOf(compiledClassesByInternalName.keySet());
    for (    String internalName : internalNames) {
      boolean reportErrors=false;
      JDeclaredType type=internalFindType(internalName,internalNameBasedTypeLocator,reportErrors);
      if (type == null) {
        continue;
      }
      fullFlowIntoType(type);
    }
  }
  instantiate(program.getTypeJavaLangString());
  flowInto(program.getIndexedMethod("Object.toString"));
  mapApi(program.getTypeJavaLangString());
  flowInto(methodMap.get("java.lang.String.valueOf(C)Ljava/lang/String;"));
  AutoboxUtils autoboxUtils=new AutoboxUtils(program);
  for (  JMethod method : autoboxUtils.getBoxMethods()) {
    flowInto(method);
  }
  for (  JMethod method : autoboxUtils.getUnboxMethods()) {
    flowInto(method);
  }
  if (compilerContext.getOptions().isRunAsyncEnabled()) {
    flowInto(program.getIndexedMethod("AsyncFragmentLoader.onLoad"));
    flowInto(program.getIndexedMethod("AsyncFragmentLoader.runAsync"));
  }
  staticInitialize(program.getTypeClassLiteralHolder());
  for (  JMethod method : program.getTypeJavaLangClass().getMethods()) {
    if (method.isStatic() && method.getName().startsWith("createFor")) {
      flowInto(method);
    }
  }
  mainLoop();
  if (incrementalCompile) {
    int declaredTypesInModule=program.getModuleDeclaredTypes().size();
    MetricName.DECLARED_TYPES_IN_MODULE.setAmount(logger,declaredTypesInModule);
    logger.log(TreeLogger.INFO,"Unification traversed " + liveFieldsAndMethods.size() + " fields and methods and "+ program.getDeclaredTypes().size()+ " types. "+ declaredTypesInModule+ " are considered part of the current module and "+ fullFlowTypes.size()+ " had all of their fields and methods traversed.");
    Set<String> remainingStaleTypeNames=computeRemainingStaleTypeNames();
    if (!remainingStaleTypeNames.isEmpty()) {
      logger.log(TreeLogger.WARN,"Some stale types (" + remainingStaleTypeNames + ") were not reprocessed as was expected. This is either a compiler bug or a "+ "Generator has legitimately stopped creating these types.");
    }
    minimalRebuildCache.setProcessedStaleTypeNames(fullFlowTypes);
  }
  computeOverrides();
  if (compilerContext.shouldCompileMonolithic()) {
    pruneDeadFieldsAndMethods();
  }
  if (errorsFound) {
    throw new UnableToCompleteException();
  }
}
