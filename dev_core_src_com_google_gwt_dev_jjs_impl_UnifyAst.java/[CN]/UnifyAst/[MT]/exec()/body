{
  for (  JMethod entryMethod : program.getEntryMethods()) {
    flowInto(entryMethod);
  }
  for (  JClassType type : program.codeGenTypes) {
    for (    JMethod method : type.getMethods()) {
      flowInto(method);
    }
    for (    JField field : type.getFields()) {
      flowInto(field);
    }
  }
  if (compilePerFile) {
    fullFlowIntoStaleTypes();
  }
 else   if (isLibraryCompile) {
    Set<String> internalNames=ImmutableSet.copyOf(compiledClassesByInternalName.keySet());
    for (    String internalName : internalNames) {
      boolean reportErrors=false;
      JDeclaredType type=internalFindType(internalName,internalNameBasedTypeLocator,reportErrors);
      if (type == null) {
        continue;
      }
      instantiate(type);
      for (      JField field : type.getFields()) {
        flowInto(field);
      }
      for (      JMethod method : type.getMethods()) {
        flowInto(method);
      }
    }
  }
  instantiate(program.getTypeJavaLangString());
  flowInto(program.getIndexedMethod("Object.toString"));
  mapApi(program.getTypeJavaLangString());
  flowInto(methodMap.get("java.lang.String.valueOf(C)Ljava/lang/String;"));
  AutoboxUtils autoboxUtils=new AutoboxUtils(program);
  for (  JMethod method : autoboxUtils.getBoxMethods()) {
    flowInto(method);
  }
  for (  JMethod method : autoboxUtils.getUnboxMethods()) {
    flowInto(method);
  }
  if (compilerContext.getOptions().isRunAsyncEnabled()) {
    flowInto(program.getIndexedMethod("AsyncFragmentLoader.onLoad"));
    flowInto(program.getIndexedMethod("AsyncFragmentLoader.runAsync"));
  }
  staticInitialize(program.getTypeClassLiteralHolder());
  for (  JMethod method : program.getTypeJavaLangClass().getMethods()) {
    if (method.isStatic() && method.getName().startsWith("createFor")) {
      flowInto(method);
    }
  }
  mainLoop();
  if (compilePerFile) {
    logger.log(TreeLogger.INFO,"Unification traversed " + liveFieldsAndMethods.size() + " fields and methods and "+ program.getDeclaredTypes().size()+ " types. "+ program.getModuleDeclaredTypes().size()+ " are considered part of the current module and "+ fullFlowTypes.size()+ " had all of their fields and methods traversed.");
    if (!staleTypeNames.isEmpty()) {
      logger.log(TreeLogger.WARN,"Some stale types (" + staleTypeNames + ") should have been but were not reprocessed. This is likely "+ "a bug. Please report it to the GWT team.");
    }
  }
  computeOverrides();
  if (compilerContext.shouldCompileMonolithic()) {
    pruneDeadFieldsAndMethods();
  }
  if (errorsFound) {
    throw new UnableToCompleteException();
  }
}
