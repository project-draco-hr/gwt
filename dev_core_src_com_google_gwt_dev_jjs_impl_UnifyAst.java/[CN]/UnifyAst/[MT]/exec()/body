{
  List<String> entryMethodNames=Lists.newArrayList();
  for (  JMethod entryMethod : program.getEntryMethods()) {
    flowInto(entryMethod);
    entryMethodNames.add(entryMethod.getJsniSignature(true,true));
  }
  List<String> rootTypeBinaryNames=Lists.newArrayList();
  for (  String rootTypeSourceName : rootTypeSourceNames) {
    JDeclaredType rootType=internalFindType(rootTypeSourceName,sourceNameBasedTypeLocator,true);
    if (rootType == null) {
      continue;
    }
    rootTypeBinaryNames.add(rootType.getName());
    if (rootType.hasJsInteropEntryPoints()) {
      fullFlowIntoType(rootType);
    }
  }
  minimalRebuildCache.setRootTypeNames(rootTypeBinaryNames);
  minimalRebuildCache.setEntryMethodNames(entryMethodNames);
  for (  JClassType type : program.codeGenTypes) {
    for (    JMethod method : type.getMethods()) {
      flowInto(method);
    }
    for (    JField field : type.getFields()) {
      flowInto(field);
    }
  }
  if (incrementalCompile) {
    fullFlowIntoRemainingStaleTypes();
  }
  instantiate(program.getTypeJavaLangString());
  flowInto(program.getIndexedMethod(RuntimeConstants.OBJECT_TO_STRING));
  mapApi(program.getTypeJavaLangString());
  flowInto(methodMap.get("java.lang.String.valueOf(C)Ljava/lang/String;"));
  AutoboxUtils autoboxUtils=new AutoboxUtils(program);
  for (  JMethod method : autoboxUtils.getBoxMethods()) {
    flowInto(method);
  }
  for (  JMethod method : autoboxUtils.getUnboxMethods()) {
    flowInto(method);
  }
  if (compilerContext.getOptions().isRunAsyncEnabled()) {
    flowInto(program.getIndexedMethod(RuntimeConstants.ASYNC_FRAGMENT_LOADER_ON_LOAD));
    flowInto(program.getIndexedMethod(RuntimeConstants.ASYNC_FRAGMENT_LOADER_RUN_ASYNC));
  }
  staticInitialize(program.getTypeClassLiteralHolder());
  for (  JMethod method : program.getTypeJavaLangClass().getMethods()) {
    if (method.isStatic() && method.getName().startsWith("createFor")) {
      flowInto(method);
    }
  }
  mainLoop();
  if (incrementalCompile) {
    int declaredTypesInModule=program.getModuleDeclaredTypes().size();
    MetricName.DECLARED_TYPES_IN_MODULE.setAmount(logger,declaredTypesInModule);
    logger.log(TreeLogger.INFO,"Unification traversed " + liveFieldsAndMethods.size() + " fields and methods and "+ program.getDeclaredTypes().size()+ " types. "+ declaredTypesInModule+ " are considered part of the current module and "+ fullFlowTypes.size()+ " had all of their fields and methods traversed.");
    Set<String> remainingStaleTypeNames=computeRemainingStaleTypeNames();
    if (!remainingStaleTypeNames.isEmpty()) {
      logger.log(TreeLogger.WARN,"Some stale types (" + remainingStaleTypeNames + ") were not reprocessed as was expected. This is either a compiler bug or a "+ "Generator has legitimately stopped creating these types.");
    }
    minimalRebuildCache.setProcessedStaleTypeNames(fullFlowTypes);
  }
  List<JMethod> newStubMethods=computeOverrides();
  for (  JMethod method : newStubMethods) {
    if (instantiatedTypes.contains(method.getEnclosingType()) && virtualMethodsLive.contains(method.getSignature())) {
      liveFieldsAndMethods.add(method);
    }
  }
  if (!incrementalCompile) {
    pruneDeadFieldsAndMethods();
  }
  if (errorsFound) {
    throw new UnableToCompleteException();
  }
}
