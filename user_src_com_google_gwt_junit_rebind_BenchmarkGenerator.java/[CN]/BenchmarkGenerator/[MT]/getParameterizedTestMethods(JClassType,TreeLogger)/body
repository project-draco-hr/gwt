{
  Map<String,List<JMethod>> testMethods=getAllMethods(requestedClass,new MethodFilter(){
    public boolean accept(    JMethod method){
      return isJUnitTestMethod(method,true);
    }
  }
);
  Map<String,JMethod> overloadedMethods=new HashMap<String,JMethod>();
  for (  Map.Entry<String,List<JMethod>> entry : testMethods.entrySet()) {
    String name=entry.getKey();
    List<JMethod> methods=entry.getValue();
    if (methods.size() > 2) {
      String msg=requestedClass + "." + name+ " has more than one overloaded version.\n"+ "It will not be included in the test case execution.";
      logger.log(TreeLogger.WARN,msg,null);
      continue;
    }
    if (methods.size() == 1) {
      JMethod method=methods.get(0);
      if (method.getParameters().length != 0) {
        String msg=requestedClass + "." + name+ " does not have a zero-argument overload.\n"+ "It will not be included in the test case execution.";
        logger.log(TreeLogger.WARN,msg,null);
      }
      continue;
    }
    JMethod method1=methods.get(0);
    JMethod method2=methods.get(1);
    JMethod noArgMethod=null;
    JMethod overloadedMethod=null;
    if (method1.getParameters().length == 0) {
      noArgMethod=method1;
    }
 else {
      overloadedMethod=method1;
    }
    if (method2.getParameters().length == 0) {
      noArgMethod=method2;
    }
 else {
      overloadedMethod=method2;
    }
    if (noArgMethod == null) {
      String msg=requestedClass + "." + name+ " does not have a zero-argument overload.\n"+ "It will not be included in the test case execution.";
      logger.log(TreeLogger.WARN,msg,null);
      continue;
    }
    overloadedMethods.put(entry.getKey(),overloadedMethod);
  }
  return overloadedMethods;
}
