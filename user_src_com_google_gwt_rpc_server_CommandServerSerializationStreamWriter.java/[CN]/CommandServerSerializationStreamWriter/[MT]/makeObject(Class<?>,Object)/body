{
  if (type.isAnonymousClass() || type.isLocalClass()) {
    throw new SerializationException("Cannot serialize anonymous or local classes");
  }
  Class<?> manualType=type;
  Class<?> customSerializer;
  do {
    customSerializer=SerializabilityUtil.hasCustomFieldSerializer(manualType);
    if (customSerializer != null) {
      break;
    }
    manualType=manualType.getSuperclass();
  }
 while (manualType != null);
  IdentityValueCommand ins;
  if (customSerializer != null) {
    ins=serializeWithCustomSerializer(customSerializer,value,type,manualType);
  }
 else {
    ins=new InstantiateCommand(type);
    identityMap.put(value,ins);
  }
  if (type != manualType) {
    if (!Serializable.class.isAssignableFrom(type) && !IsSerializable.class.isAssignableFrom(type)) {
      throw new SerializationException(type.getName() + " is not a serializable type");
    }
  }
  while (type != manualType) {
    Field[] serializableFields=clientOracle.getOperableFields(type);
    for (    Field declField : serializableFields) {
      assert(declField != null);
      Accessor accessor=CommandSerializationUtil.getAccessor(declField.getType());
      ValueCommand valueCommand;
      Object fieldValue=accessor.get(value,declField);
      if (fieldValue == null) {
        valueCommand=NullValueCommand.INSTANCE;
      }
 else {
        Class<? extends Object> fieldType=declField.getType().isPrimitive() ? declField.getType() : fieldValue.getClass();
        valueCommand=makeValue(fieldType,fieldValue);
      }
      ((HasSetters)ins).set(declField.getDeclaringClass(),declField.getName(),valueCommand);
    }
    type=type.getSuperclass();
  }
  return ins;
}
