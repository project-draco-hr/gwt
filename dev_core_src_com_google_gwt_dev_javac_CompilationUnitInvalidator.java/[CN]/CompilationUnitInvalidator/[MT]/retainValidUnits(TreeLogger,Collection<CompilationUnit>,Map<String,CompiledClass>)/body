{
  logger=logger.branch(TreeLogger.TRACE,"Removing invalidated units");
  Set<CompilationUnit> currentlyValidUnits=new HashSet<CompilationUnit>();
  Set<String> currentlyValidClasses=new HashSet<String>();
  for (  CompilationUnit unit : units) {
    if (!unit.isError()) {
      currentlyValidUnits.add(unit);
      for (      CompiledClass cc : unit.getCompiledClasses()) {
        currentlyValidClasses.add(cc.getSourceName());
      }
    }
  }
  for (  Entry<String,CompiledClass> entry : validClasses.entrySet()) {
    if (!entry.getValue().getUnit().isError()) {
      currentlyValidClasses.add(entry.getKey());
    }
  }
  boolean changed;
  do {
    changed=false;
    for (Iterator<CompilationUnit> it=currentlyValidUnits.iterator(); it.hasNext(); ) {
      CompilationUnit unitToCheck=it.next();
      List<String> missingDeps=unitToCheck.getDependencies().findMissingDeps(currentlyValidClasses);
      if (missingDeps.size() > 0) {
        TreeLogger branch=logger.branch(TreeLogger.DEBUG,"Compilation unit '" + unitToCheck + "' is removed due to invalid reference(s):");
        it.remove();
        for (        CompiledClass cc : unitToCheck.getCompiledClasses()) {
          currentlyValidClasses.remove(cc.getSourceName());
        }
        changed=true;
        for (        String dep : missingDeps) {
          branch.log(TreeLogger.DEBUG,dep);
        }
      }
    }
  }
 while (changed);
  units.retainAll(currentlyValidUnits);
}
