{
  job.onProgress("Loading modules");
  CompilerOptions loadOptions=new CompilerOptionsImpl(compileDir,inputModuleName,options);
  compilerContext=compilerContextBuilder.options(loadOptions).build();
  ModuleDef module=loadModule(job.getBindingProperties().keySet(),compileLogger);
  String recompileJs=generateModuleRecompileJs(module,compileLogger);
  Map<String,String> bindingProperties=restrictPermutations(compileLogger,module,job.getBindingProperties());
  String newModuleName=module.getName();
  outputModuleName.set(newModuleName);
  InputSummary input=new InputSummary(bindingProperties,module);
  if (input.equals(lastBuildInput)) {
    compileLogger.log(Type.INFO,"skipped compile because no input files have changed");
    job.setCompileStrategy(CompileStrategy.SKIPPED);
    return true;
  }
  job.onProgress("Compiling");
  CompilerOptions runOptions=new CompilerOptionsImpl(compileDir,newModuleName,options);
  compilerContext=compilerContextBuilder.options(runOptions).build();
  MinimalRebuildCache knownGoodMinimalRebuildCache=getKnownGoodMinimalRebuildCache(bindingProperties);
  job.setCompileStrategy(knownGoodMinimalRebuildCache.isPopulated() ? CompileStrategy.INCREMENTAL : CompileStrategy.FULL);
  MinimalRebuildCache mutableMinimalRebuildCache=new MinimalRebuildCache();
  mutableMinimalRebuildCache.copyFrom(knownGoodMinimalRebuildCache);
  boolean success=new Compiler(runOptions,mutableMinimalRebuildCache).run(compileLogger,module);
  if (success) {
    publishedCompileDir=compileDir;
    lastBuildInput=input;
    saveKnownGoodMinimalRebuildCache(bindingProperties,mutableMinimalRebuildCache);
    String moduleName=outputModuleName.get();
    writeRecompileNoCacheJs(new File(publishedCompileDir.getWarDir(),moduleName),moduleName,recompileJs,compileLogger);
  }
 else {
    lastBuildInput=null;
  }
  lastBuild.set(compileDir);
  return success;
}
