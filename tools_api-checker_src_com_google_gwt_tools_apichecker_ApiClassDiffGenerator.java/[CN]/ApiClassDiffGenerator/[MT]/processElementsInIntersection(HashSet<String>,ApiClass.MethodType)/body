{
  if (intersection.size() == 0) {
    return;
  }
  HashSet<JAbstractMethod> missingElements=missingMethods.get(methodType.getId());
  HashMap<JAbstractMethod,HashSet<ApiChange>> intersectingElements=intersectingMethods.get(methodType.getId());
  HashSet<ApiAbstractMethod> onlyInExisting=new HashSet<ApiAbstractMethod>();
  HashSet<ApiAbstractMethod> onlyInNew=new HashSet<ApiAbstractMethod>();
  HashSet<String> commonSignature=new HashSet<String>();
  Iterator<String> intersectionNames=intersection.iterator();
  while (intersectionNames.hasNext()) {
    String tempName=intersectionNames.next();
    HashSet<ApiAbstractMethod> methodsInNew=newClass.getApiMethodsByName(tempName,methodType);
    HashSet<ApiAbstractMethod> methodsInExisting=oldClass.getApiMethodsByName(tempName,methodType);
    onlyInNew.addAll(methodsInNew);
    onlyInExisting.addAll(methodsInExisting);
    if (isIncompatibileDueToMethodOverloading(methodsInNew,methodsInExisting)) {
      addProperty(intersectingElements,methodsInExisting.toArray(new ApiAbstractMethod[0])[0].getMethodObject(),new ApiChange(ApiChange.Status.OVERLOADED,"Many methods in the new API with similar signatures. Methods = " + methodsInNew + " This might break API source compatibility"));
    }
    Iterator<ApiAbstractMethod> iterator1=methodsInExisting.iterator();
    while (iterator1.hasNext()) {
      ApiAbstractMethod methodInExisting=iterator1.next();
      Iterator<ApiAbstractMethod> iterator2=methodsInNew.iterator();
      while (iterator2.hasNext()) {
        ApiAbstractMethod methodInNew=iterator2.next();
        if (methodInExisting.isCompatible(methodInNew)) {
          ApiChange returnType=methodInExisting.checkReturnTypeCompatibility(methodInNew);
          if (returnType != null) {
            addProperty(intersectingElements,methodInExisting.getMethodObject(),returnType);
          }
          Iterator<ApiChange> apiChangeIterator=checkExceptions(methodInNew.getMethodObject(),methodInExisting.getMethodObject()).iterator();
          while (apiChangeIterator.hasNext()) {
            addProperty(intersectingElements,methodInExisting.getMethodObject(),apiChangeIterator.next());
          }
          Iterator<ApiChange.Status> apiChanges=methodInExisting.getModifierChanges(methodInNew).iterator();
          while (apiChanges.hasNext()) {
            addProperty(intersectingElements,methodInExisting.getMethodObject(),new ApiChange(apiChanges.next()));
          }
          onlyInNew.remove(methodInNew);
          onlyInExisting.remove(methodInExisting);
          String signatureInNew=methodInNew.getApiSignature();
          String signatureInExisting=methodInExisting.getApiSignature();
          if (signatureInNew.equals(signatureInExisting)) {
            commonSignature.add(signatureInNew);
            addProperty(intersectingElements,methodInExisting.getMethodObject(),new ApiChange(ApiChange.Status.COMPATIBLE));
          }
 else {
            addProperty(intersectingElements,methodInExisting.getMethodObject(),new ApiChange(ApiChange.Status.COMPATIBLE_WITH," compatible with " + signatureInNew));
          }
        }
      }
    }
  }
  missingElements.addAll(getAbstractMethodObjects(onlyInExisting));
}
