{
  try {
    JProgram jprogram=new JProgram(logger,rebindOracle);
    TypeMap typeMap=new TypeMap(jprogram);
    JsProgram jsProgram=new JsProgram();
    TypeDeclaration[] allTypeDeclarations=BuildTypeMap.exec(typeMap,goldenCuds,jsProgram);
    checkForErrors(logger,true);
    jprogram.typeOracle.computeBeforeAST();
    GenerateJavaAST.exec(allTypeDeclarations,typeMap,jprogram,jsProgram,options.isEnableAssertions());
    checkForErrors(logger,true);
    if (options.isEnableAssertions()) {
      AssertionNormalizer.exec(jprogram);
    }
 else {
      AssertionRemover.exec(jprogram);
    }
    ReplaceRebinds.exec(jprogram);
    if (options.isValidateOnly()) {
      return null;
    }
    findEntryPoints(logger,rebindOracle,declEntryPoints,jprogram);
    boolean didChange;
    do {
      jprogram.typeOracle.recomputeClinits();
      didChange=false;
      didChange=Pruner.exec(jprogram,true) || didChange;
      didChange=MethodAndClassFinalizer.exec(jprogram) || didChange;
      didChange=MakeCallsStatic.exec(jprogram) || didChange;
      didChange=TypeTightener.exec(jprogram) || didChange;
      didChange=MethodCallTightener.exec(jprogram) || didChange;
      didChange=DeadCodeElimination.exec(jprogram) || didChange;
      if (options.isAggressivelyOptimize()) {
        didChange=MethodInliner.exec(jprogram) || didChange;
      }
    }
 while (didChange);
    CatchBlockNormalizer.exec(jprogram);
    CompoundAssignmentNormalizer.exec(jprogram);
    JavaScriptObjectCaster.exec(jprogram);
    CastNormalizer.exec(jprogram);
    ArrayNormalizer.exec(jprogram);
    Pruner.exec(jprogram,false);
    jprogram.typeOracle.recomputeClinits();
    GenerateJavaScriptAST.exec(jprogram,jsProgram,options.getOutput());
    JsNormalizer.exec(jsProgram);
    JsSymbolResolver.exec(jsProgram);
    if (options.isAggressivelyOptimize()) {
      do {
        didChange=false;
        didChange=options.isAggressivelyOptimize() && JsInliner.exec(jsProgram) || didChange;
        didChange=JsUnusedFunctionRemover.exec(jsProgram) || didChange;
      }
 while (didChange);
    }
switch (options.getOutput()) {
case OBFUSCATED:
      JsStringInterner.exec(jsProgram);
    JsObfuscateNamer.exec(jsProgram);
  break;
case PRETTY:
JsPrettyNamer.exec(jsProgram);
break;
case DETAILED:
JsStringInterner.exec(jsProgram);
JsVerboseNamer.exec(jsProgram);
break;
default :
throw new InternalCompilerException("Unknown output mode");
}
DefaultTextOutput out=new DefaultTextOutput(options.getOutput().shouldMinimize());
JsSourceGenerationVisitor v=new JsSourceGenerationVisitor(out);
v.accept(jsProgram);
return out.toString();
}
 catch (UnableToCompleteException e) {
throw e;
}
catch (InternalCompilerException e) {
TreeLogger topBranch=logger.branch(TreeLogger.ERROR,"An internal compiler exception occurred",e);
List<NodeInfo> nodeTrace=e.getNodeTrace();
for (NodeInfo nodeInfo : nodeTrace) {
SourceInfo info=nodeInfo.getSourceInfo();
String msg;
if (info != null) {
String fileName=info.getFileName();
fileName=fileName.substring(fileName.lastIndexOf('/') + 1);
fileName=fileName.substring(fileName.lastIndexOf('\\') + 1);
msg="at " + fileName + "("+ info.getStartLine()+ "): ";
}
 else {
msg="<no source info>: ";
}
String description=nodeInfo.getDescription();
if (description != null) {
msg+=description;
}
 else {
msg+="<no description available>";
}
TreeLogger nodeBranch=topBranch.branch(TreeLogger.ERROR,msg,null);
String className=nodeInfo.getClassName();
if (className != null) {
nodeBranch.log(TreeLogger.INFO,className,null);
}
}
throw new UnableToCompleteException();
}
catch (Throwable e) {
logger.log(TreeLogger.ERROR,"Unexpected internal compiler error",e);
throw new UnableToCompleteException();
}
}
