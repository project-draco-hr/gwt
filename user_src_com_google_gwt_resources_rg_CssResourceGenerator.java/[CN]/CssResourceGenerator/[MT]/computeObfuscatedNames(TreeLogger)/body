{
  logger=logger.branch(TreeLogger.DEBUG,"Computing CSS class replacements");
  SortedSet<JClassType> cssResourceSubtypes=computeOperableTypes(logger);
  if (classPrefix == null) {
    Adler32 checksum=new Adler32();
    for (    JClassType type : cssResourceSubtypes) {
      checksum.update(Util.getBytes(type.getQualifiedSourceName()));
    }
    classPrefix="G" + Long.toString(checksum.getValue(),Character.MAX_RADIX);
  }
  int count=0;
  for (  JClassType type : cssResourceSubtypes) {
    Map<JMethod,String> replacements=new IdentityHashMap<JMethod,String>();
    replacementsByClassAndMethod.put(type,replacements);
    for (    JMethod method : type.getOverridableMethods()) {
      String name=method.getName();
      if ("getName".equals(name) || "getText".equals(name) || !stringType.equals(method.getReturnType())) {
        continue;
      }
      ClassName classNameOverride=method.getAnnotation(ClassName.class);
      if (classNameOverride != null) {
        name=classNameOverride.value();
      }
      String obfuscatedClassName;
      if (prettyOutput) {
        obfuscatedClassName=classPrefix + "-" + type.getQualifiedSourceName().replaceAll("[.$]","-")+ "-"+ name;
      }
 else {
        obfuscatedClassName=classPrefix + makeIdent(count++);
      }
      replacements.put(method,obfuscatedClassName);
      if (method.getEnclosingType() == type) {
        Shared shared=type.getAnnotation(Shared.class);
        if (shared != null) {
          replacementsForSharedMethods.put(method,obfuscatedClassName);
        }
      }
      logger.log(TreeLogger.SPAM,"Mapped " + type.getQualifiedSourceName() + "."+ name+ " to "+ obfuscatedClassName);
    }
  }
}
