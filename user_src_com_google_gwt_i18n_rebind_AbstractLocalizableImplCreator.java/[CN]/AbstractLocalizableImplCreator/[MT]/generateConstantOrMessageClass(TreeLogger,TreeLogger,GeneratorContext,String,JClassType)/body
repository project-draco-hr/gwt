{
  TypeOracle oracle=context.getTypeOracle();
  JClassType constantsClass;
  JClassType messagesClass;
  JClassType constantsWithLookupClass;
  boolean seenError=false;
  try {
    constantsClass=oracle.getType(LocalizableGenerator.CONSTANTS_NAME);
    constantsWithLookupClass=oracle.getType(LocalizableGenerator.CONSTANTS_WITH_LOOKUP_NAME);
    messagesClass=oracle.getType(LocalizableGenerator.MESSAGES_NAME);
  }
 catch (  NotFoundException e) {
    throw error(logger,e);
  }
  String name=targetClass.getName();
  String packageName=targetClass.getPackage().getName();
  boolean assignableToConstants=constantsClass.isAssignableFrom(targetClass);
  boolean assignableToMessages=messagesClass.isAssignableFrom(targetClass);
  if (!assignableToConstants && !assignableToMessages) {
    return null;
  }
  if (assignableToConstants && assignableToMessages) {
    throw error(logger,name + " cannot extend both Constants and Messages");
  }
  if (targetClass.isInterface() == null) {
    throw error(logger,name + " must be an interface");
  }
  AbstractResource resource=null;
  try {
    resource=ResourceFactory.getBundle(logger,targetClass,locale,assignableToConstants);
  }
 catch (  MissingResourceException e) {
    throw error(logger,"Localization failed; there must be at least one properties file accessible through" + " the classpath in package '" + packageName + "' whose base name is '"+ ResourceFactory.getResourceName(targetClass)+ "'");
  }
catch (  IllegalArgumentException e) {
    throw error(logger,e.getMessage());
  }
  String localeSuffix=String.valueOf(ResourceFactory.LOCALE_SEPARATOR);
  if (!ResourceFactory.DEFAULT_TOKEN.equals(locale)) {
    localeSuffix+=locale;
  }
  String resourceName=targetClass.getName().replace('.','_');
  String className=resourceName + localeSuffix;
  PrintWriter pw=context.tryCreate(logger,packageName,className);
  if (pw != null) {
    ClassSourceFileComposerFactory factory=new ClassSourceFileComposerFactory(packageName,className);
    factory.addImplementedInterface(targetClass.getQualifiedSourceName());
    SourceWriter writer=factory.createSourceWriter(context,pw);
    if (constantsWithLookupClass.isAssignableFrom(targetClass)) {
      ConstantsWithLookupImplCreator c=new ConstantsWithLookupImplCreator(logger,deprecatedLogger,writer,targetClass,resource,context.getTypeOracle());
      c.emitClass(logger,locale);
    }
 else     if (constantsClass.isAssignableFrom(targetClass)) {
      ConstantsImplCreator c=new ConstantsImplCreator(logger,deprecatedLogger,writer,targetClass,resource,context.getTypeOracle());
      c.emitClass(logger,locale);
    }
 else {
      MessagesImplCreator messages=new MessagesImplCreator(logger,deprecatedLogger,writer,targetClass,resource,context.getTypeOracle());
      messages.emitClass(logger,locale);
    }
    context.commit(logger,pw);
  }
  Generate generate=targetClass.getAnnotation(Generate.class);
  if (generate != null) {
    String path=generate.fileName();
    if (Generate.DEFAULT.equals(path)) {
      path=targetClass.getPackage().getName() + "." + targetClass.getName().replace('.','_');
    }
 else     if (path.endsWith(File.pathSeparator)) {
      path=path + targetClass.getName().replace('.','_');
    }
    String[] genLocales=generate.locales();
    boolean found=false;
    if (genLocales.length != 0) {
      for (      String genLocale : genLocales) {
        if (genLocale.equals(locale)) {
          found=true;
          break;
        }
      }
    }
 else {
      found=true;
    }
    if (found) {
      for (      String genClassName : generate.format()) {
        MessageCatalogFormat msgWriter=null;
        try {
          Class<? extends MessageCatalogFormat> msgFormatClass=Class.forName(genClassName,false,MessageCatalogFormat.class.getClassLoader()).asSubclass(MessageCatalogFormat.class);
          msgWriter=msgFormatClass.newInstance();
        }
 catch (        InstantiationException e) {
          logger.log(TreeLogger.ERROR,"Error instantiating @Generate class " + genClassName,e);
          seenError=true;
          continue;
        }
catch (        IllegalAccessException e) {
          logger.log(TreeLogger.ERROR,"@Generate class " + genClassName + " illegal access",e);
          seenError=true;
          continue;
        }
catch (        ClassNotFoundException e) {
          logger.log(TreeLogger.ERROR,"@Generate class " + genClassName + " not found");
          seenError=true;
          continue;
        }
        String genPath=path;
        if (genLocales.length != 1) {
          genPath+='_' + locale;
        }
        genPath+=msgWriter.getExtension();
        OutputStream outStr=context.tryCreateResource(logger,genPath);
        if (outStr != null) {
          TreeLogger branch=logger.branch(TreeLogger.INFO,"Generating " + genPath + " from "+ className+ " for locale "+ locale,null);
          PrintWriter out=null;
          try {
            out=new PrintWriter(new BufferedWriter(new OutputStreamWriter(outStr,"UTF-8")),false);
          }
 catch (          UnsupportedEncodingException e) {
            throw error(logger,e.getMessage());
          }
          try {
            msgWriter.write(branch,resource,out,targetClass);
            out.flush();
            context.commitResource(logger,outStr).setPrivate(true);
          }
 catch (          UnableToCompleteException e) {
            seenError=true;
          }
        }
      }
    }
  }
  if (seenError) {
    throw new UnableToCompleteException();
  }
  return packageName + "." + className;
}
