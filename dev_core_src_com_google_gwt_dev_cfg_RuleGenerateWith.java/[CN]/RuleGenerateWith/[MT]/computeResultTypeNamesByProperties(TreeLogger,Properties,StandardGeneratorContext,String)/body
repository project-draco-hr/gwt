{
  Map<Map<String,String>,String> resultTypeNamesByProperties=Maps.newLinkedHashMap();
  DynamicPropertyOracle dynamicPropertyOracle=new DynamicPropertyOracle(moduleProperties);
  if (!accessedPropertyNames.equals(ALL_PROPERTIES)) {
    for (    String accessedPropertyName : accessedPropertyNames) {
      try {
        dynamicPropertyOracle.getSelectionProperty(logger,accessedPropertyName);
      }
 catch (      BadPropertyValueException e) {
      }
    }
  }
  boolean needsAllTypesIfRun=contentDependsOnTypes() && context.isGlobalCompile();
  TypeOracle typeModelTypeOracle=(com.google.gwt.dev.javac.typemodel.TypeOracle)context.getTypeOracle();
  context.setPropertyOracle(dynamicPropertyOracle);
  context.setCurrentGenerator(generatorClass);
  do {
    resultTypeNamesByProperties.clear();
    Properties accessedProperties=new Properties();
    List<BindingProperty> accessedPropertiesList=new ArrayList<BindingProperty>(dynamicPropertyOracle.getAccessedProperties());
    for (    BindingProperty bindingProperty : accessedPropertiesList) {
      accessedProperties.addBindingProperty(bindingProperty);
    }
    PropertyPermutations permutationsOfAccessedProperties=new PropertyPermutations(accessedProperties,Sets.<String>newHashSet());
    for (int permutationId=0; permutationId < permutationsOfAccessedProperties.size(); permutationId++) {
      String[] orderedPropertyValues=permutationsOfAccessedProperties.getOrderedPropertyValues(permutationId);
      BindingProperty[] orderedProperties=permutationsOfAccessedProperties.getOrderedProperties();
      dynamicPropertyOracle.reset();
      for (int propertyIndex=0; propertyIndex < orderedPropertyValues.length; propertyIndex++) {
        dynamicPropertyOracle.prescribePropertyValue(orderedProperties[propertyIndex].getName(),orderedPropertyValues[propertyIndex]);
      }
      if (!isApplicable(logger,context,typeName)) {
        continue;
      }
      if (needsAllTypesIfRun) {
        typeModelTypeOracle.ensureAllLoaded();
      }
      String resultTypeName;
      try {
        resultTypeName=getGenerator().generate(logger,context,typeName);
      }
 catch (      UnsupportedTypeOracleAccess e) {
        logger.log(TreeLogger.ERROR,String.format("TypeOracle error when running generator '%s' in an incremental compile: %s",getName(),e.getMessage()));
        throw new UnableToCompleteException();
      }
      if (resultTypeName != null) {
        resultTypeNamesByProperties.put(dynamicPropertyOracle.getPrescribedPropertyValuesByName(),resultTypeName);
      }
      if (dynamicPropertyOracle.haveAccessedPropertiesChanged()) {
        break;
      }
    }
  }
 while (dynamicPropertyOracle.haveAccessedPropertiesChanged());
  return resultTypeNamesByProperties;
}
