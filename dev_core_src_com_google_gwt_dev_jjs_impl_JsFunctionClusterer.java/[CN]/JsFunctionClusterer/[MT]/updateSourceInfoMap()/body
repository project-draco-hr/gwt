{
  if (sourceInfoMap != null) {
    Map<Range,Range> statementShifts=new HashMap<Range,Range>();
    for (int j=0; j < statementRanges.numStatements(); j++) {
      int permutedStart=statementRanges.start(j);
      int permutedEnd=statementRanges.end(j);
      int originalStart=originalStatementRanges.start(reorderedIndices[j]);
      int originalEnd=originalStatementRanges.end(reorderedIndices[j]);
      statementShifts.put(new Range(originalStart,originalEnd),new Range(permutedStart,permutedEnd));
    }
    Range[] oldStatementRanges=statementShifts.keySet().toArray(new Range[0]);
    Arrays.sort(oldStatementRanges,Range.SOURCE_ORDER_COMPARATOR);
    List<Range> oldExpressionRanges=Lists.newArrayList(sourceInfoMap.getRanges());
    Collections.sort(oldExpressionRanges,Range.SOURCE_ORDER_COMPARATOR);
    List<Range> updatedRanges=Lists.newArrayList();
    Range entireProgram=new Range(0,oldStatementRanges[oldStatementRanges.length - 1].getEnd());
    for (int i=0, j=0; j < oldExpressionRanges.size(); j++) {
      Range oldExpression=oldExpressionRanges.get(j);
      if (oldExpression.equals(entireProgram)) {
        updatedRanges.add(oldExpression);
        continue;
      }
      Range oldStatement=oldStatementRanges[i];
      Range newStatement=statementShifts.get(oldStatement);
      int shift=newStatement.getStart() - oldStatement.getStart();
      Range oldExpressionRange=oldExpressionRanges.get(j);
      Range newExpressionRange=new Range(oldExpressionRange.getStart() + shift,oldExpressionRange.getEnd() + shift,oldExpressionRange.getSourceInfo());
      updatedRanges.add(newExpressionRange);
    }
    sourceInfoMap=new JsSourceMap(updatedRanges,sourceInfoMap.getBytes(),sourceInfoMap.getLines());
  }
}
