{
  PerfLogger.start("TypeOracleBuilder.build");
  Set<CompilationUnitProvider> addedCups=cacheManager.getAddedCups();
  TypeOracle oracle=cacheManager.getTypeOracle();
  for (Iterator<CompilationUnitProvider> iter=addedCups.iterator(); iter.hasNext(); ) {
    CompilationUnitProvider cup=iter.next();
    String location=cup.getLocation();
    if (!((location.indexOf("http://") != -1) || (location.indexOf("ftp://") != -1))) {
      location=Util.findFileName(location);
      if (!(new File(location).exists() || cup.isTransient())) {
        iter.remove();
        logger.log(TreeLogger.TRACE,"The file " + location + " was removed by the user.  All types therein are now unavailable.",null);
      }
    }
  }
  CompilationUnitProvider[] cups=Util.toArray(CompilationUnitProvider.class,addedCups);
  Arrays.sort(cups,CompilationUnitProvider.LOCATION_COMPARATOR);
  boolean foundJavaLangPackage=oracle.findPackage("java.lang") != null;
  ICompilationUnit[] units=new ICompilationUnit[cups.length];
  for (int i=0; i < cups.length; i++) {
    if (!foundJavaLangPackage && cups[i].getPackageName().equals("java.lang")) {
      foundJavaLangPackage=true;
    }
    units[i]=cacheManager.findUnitForCup(cups[i]);
  }
  if (!foundJavaLangPackage) {
    Util.logMissingTypeErrorWithHints(logger,"java.lang.Object");
    throw new UnableToCompleteException();
  }
  PerfLogger.start("TypeOracleBuilder.build (compile)");
  CompilationUnitDeclaration[] cuds=cacheManager.getAstCompiler().getChangedCompilationUnitDeclarations(logger,units);
  PerfLogger.end();
  final Map<String,CompilationUnitDeclaration> unchangedCudsByFileName=new TreeMap<String,CompilationUnitDeclaration>();
  unchangedCudsByFileName.putAll(cacheManager.getCudsByFileName());
  final Map<String,CompilationUnitDeclaration> changedCudsByFileName=new TreeMap<String,CompilationUnitDeclaration>();
  for (int i=0; i < cuds.length; i++) {
    CompilationUnitDeclaration cud=cuds[i];
    String fileName=String.valueOf(cud.getFileName());
    changedCudsByFileName.put(fileName,cud);
    unchangedCudsByFileName.remove(fileName);
  }
  cacheManager.getCudsByFileName().putAll(changedCudsByFileName);
  removeUnitsWithErrors(logger,changedCudsByFileName,unchangedCudsByFileName);
  final CacheManager.Mapper identityMapper=cacheManager.getIdentityMapper();
  for (Iterator<CompilationUnitDeclaration> iter=changedCudsByFileName.values().iterator(); iter.hasNext(); ) {
    CompilationUnitDeclaration cud=iter.next();
    cud.traverse(new ASTVisitor(){
      @Override public boolean visit(      TypeDeclaration typeDecl,      BlockScope scope){
        JClassType enclosingType=identityMapper.get(typeDecl.binding.enclosingType());
        processType(typeDecl,enclosingType,true);
        return true;
      }
      @Override public boolean visit(      TypeDeclaration typeDecl,      ClassScope scope){
        JClassType enclosingType=identityMapper.get(typeDecl.binding.enclosingType());
        processType(typeDecl,enclosingType,false);
        return true;
      }
      @Override public boolean visit(      TypeDeclaration typeDecl,      CompilationUnitScope scope){
        processType(typeDecl,null,false);
        return true;
      }
    }
,cud.scope);
  }
  for (Iterator<CompilationUnitDeclaration> iter=changedCudsByFileName.values().iterator(); iter.hasNext(); ) {
    CompilationUnitDeclaration cud=iter.next();
    String loc=String.valueOf(cud.getFileName());
    String processing="Processing types in compilation unit: " + loc;
    final TreeLogger cudLogger=logger.branch(TreeLogger.SPAM,processing,null);
    final char[] source=cud.compilationResult.compilationUnit.getContents();
    cud.traverse(new ASTVisitor(){
      @Override public boolean visit(      TypeDeclaration typeDecl,      BlockScope scope){
        if (!resolveTypeDeclaration(cudLogger,source,typeDecl)) {
          String name=String.valueOf(typeDecl.binding.readableName());
          String msg="Unexpectedly unable to fully resolve type " + name;
          logger.log(TreeLogger.WARN,msg,null);
        }
        return true;
      }
      @Override public boolean visit(      TypeDeclaration typeDecl,      ClassScope scope){
        if (!resolveTypeDeclaration(cudLogger,source,typeDecl)) {
          String name=String.valueOf(typeDecl.binding.readableName());
          String msg="Unexpectedly unable to fully resolve type " + name;
          logger.log(TreeLogger.WARN,msg,null);
        }
        return true;
      }
      @Override public boolean visit(      TypeDeclaration typeDecl,      CompilationUnitScope scope){
        if (!resolveTypeDeclaration(cudLogger,source,typeDecl)) {
          String name=String.valueOf(typeDecl.binding.readableName());
          String msg="Unexpectedly unable to fully resolve type " + name;
          logger.log(TreeLogger.WARN,msg,null);
        }
        return true;
      }
    }
,cud.scope);
  }
  Util.invokeInaccessableMethod(TypeOracle.class,"refresh",new Class[]{TreeLogger.class},oracle,new Object[]{logger});
  PerfLogger.end();
  return oracle;
}
