{
  if ((method.modifiers & ExtraCompilerModifiers.AccUnresolved) == 0)   return method;
  if (this.scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5) {
    if ((method.getAnnotationTagBits() & TagBits.AnnotationDeprecated) != 0)     method.modifiers|=ClassFileConstants.AccDeprecated;
  }
  if (isViewedAsDeprecated() && !method.isDeprecated())   method.modifiers|=ExtraCompilerModifiers.AccDeprecatedImplicitly;
  if (hasRestrictedAccess())   method.modifiers|=ExtraCompilerModifiers.AccRestrictedAccess;
  AbstractMethodDeclaration methodDecl=method.sourceMethod();
  if (methodDecl == null)   return null;
  TypeParameter[] typeParameters=methodDecl.typeParameters();
  if (typeParameters != null) {
    methodDecl.scope.connectTypeVariables(typeParameters,true);
    for (int i=0, paramLength=typeParameters.length; i < paramLength; i++)     typeParameters[i].checkBounds(methodDecl.scope);
  }
  TypeReference[] exceptionTypes=methodDecl.thrownExceptions;
  if (exceptionTypes != null) {
    int size=exceptionTypes.length;
    method.thrownExceptions=new ReferenceBinding[size];
    int count=0;
    ReferenceBinding resolvedExceptionType;
    for (int i=0; i < size; i++) {
      resolvedExceptionType=(ReferenceBinding)exceptionTypes[i].resolveType(methodDecl.scope,true);
      if (resolvedExceptionType == null)       continue;
      if (resolvedExceptionType.isBoundParameterizedType()) {
        methodDecl.scope.problemReporter().invalidParameterizedExceptionType(resolvedExceptionType,exceptionTypes[i]);
        continue;
      }
      if (resolvedExceptionType.findSuperTypeOriginatingFrom(TypeIds.T_JavaLangThrowable,true) == null) {
        if (resolvedExceptionType.isValidBinding()) {
          methodDecl.scope.problemReporter().cannotThrowType(exceptionTypes[i],resolvedExceptionType);
          continue;
        }
      }
      if ((resolvedExceptionType.tagBits & TagBits.HasMissingType) != 0) {
        method.tagBits|=TagBits.HasMissingType;
      }
      method.modifiers|=(resolvedExceptionType.modifiers & ExtraCompilerModifiers.AccGenericSignature);
      method.thrownExceptions[count++]=resolvedExceptionType;
    }
    if (count < size)     System.arraycopy(method.thrownExceptions,0,method.thrownExceptions=new ReferenceBinding[count],0,count);
  }
  boolean foundArgProblem=false;
  Argument[] arguments=methodDecl.arguments;
  if (arguments != null) {
    int size=arguments.length;
    method.parameters=Binding.NO_PARAMETERS;
    TypeBinding[] newParameters=new TypeBinding[size];
    for (int i=0; i < size; i++) {
      Argument arg=arguments[i];
      if (arg.annotations != null) {
        method.tagBits|=TagBits.HasParameterAnnotations;
      }
      TypeBinding parameterType=arg.type.resolveType(methodDecl.scope,true);
      if (parameterType == null) {
        foundArgProblem=true;
      }
 else       if (parameterType == TypeBinding.VOID) {
        methodDecl.scope.problemReporter().argumentTypeCannotBeVoid(this,methodDecl,arg);
        foundArgProblem=true;
      }
 else {
        if ((parameterType.tagBits & TagBits.HasMissingType) != 0) {
          method.tagBits|=TagBits.HasMissingType;
        }
        TypeBinding leafType=parameterType.leafComponentType();
        if (leafType instanceof ReferenceBinding && (((ReferenceBinding)leafType).modifiers & ExtraCompilerModifiers.AccGenericSignature) != 0)         method.modifiers|=ExtraCompilerModifiers.AccGenericSignature;
        newParameters[i]=parameterType;
        arg.binding=new LocalVariableBinding(arg,parameterType,arg.modifiers,true);
      }
    }
    if (!foundArgProblem) {
      method.parameters=newParameters;
    }
  }
  boolean foundReturnTypeProblem=false;
  if (!method.isConstructor()) {
    TypeReference returnType=methodDecl instanceof MethodDeclaration ? ((MethodDeclaration)methodDecl).returnType : null;
    if (returnType == null) {
      methodDecl.scope.problemReporter().missingReturnType(methodDecl);
      method.returnType=null;
      foundReturnTypeProblem=true;
    }
 else {
      TypeBinding methodType=returnType.resolveType(methodDecl.scope,true);
      if (methodType == null) {
        foundReturnTypeProblem=true;
      }
 else       if (methodType.isArrayType() && ((ArrayBinding)methodType).leafComponentType == TypeBinding.VOID) {
        methodDecl.scope.problemReporter().returnTypeCannotBeVoidArray((MethodDeclaration)methodDecl);
        foundReturnTypeProblem=true;
      }
 else {
        if ((methodType.tagBits & TagBits.HasMissingType) != 0) {
          method.tagBits|=TagBits.HasMissingType;
        }
        method.returnType=methodType;
        TypeBinding leafType=methodType.leafComponentType();
        if (leafType instanceof ReferenceBinding && (((ReferenceBinding)leafType).modifiers & ExtraCompilerModifiers.AccGenericSignature) != 0)         method.modifiers|=ExtraCompilerModifiers.AccGenericSignature;
      }
    }
  }
  if (foundArgProblem) {
    methodDecl.binding=null;
    method.parameters=Binding.NO_PARAMETERS;
    if (typeParameters != null)     for (int i=0, length=typeParameters.length; i < length; i++)     typeParameters[i].binding=null;
    return null;
  }
  if (foundReturnTypeProblem)   return method;
  method.modifiers&=~ExtraCompilerModifiers.AccUnresolved;
  return method;
}
