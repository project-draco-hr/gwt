{
  if ((this.tagBits & TagBits.AreMethodsComplete) != 0)   return this.methods;
  if ((this.tagBits & TagBits.AreMethodsSorted) == 0) {
    int length=this.methods.length;
    if (length > 1)     ReferenceBinding.sortMethods(this.methods,0,length);
    this.tagBits|=TagBits.AreMethodsSorted;
  }
  int failed=0;
  MethodBinding[] resolvedMethods=this.methods;
  try {
    for (int i=0, length=this.methods.length; i < length; i++) {
      if (resolveTypesFor(this.methods[i]) == null) {
        if (resolvedMethods == this.methods) {
          System.arraycopy(this.methods,0,resolvedMethods=new MethodBinding[length],0,length);
        }
        resolvedMethods[i]=null;
        failed++;
      }
    }
    boolean complyTo15=this.scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5;
    for (int i=0, length=this.methods.length; i < length; i++) {
      MethodBinding method=resolvedMethods[i];
      if (method == null)       continue;
      char[] selector=method.selector;
      AbstractMethodDeclaration methodDecl=null;
      nextSibling:       for (int j=i + 1; j < length; j++) {
        MethodBinding method2=resolvedMethods[j];
        if (method2 == null)         continue nextSibling;
        if (!CharOperation.equals(selector,method2.selector))         break nextSibling;
        if (complyTo15 && method.returnType != null && method2.returnType != null) {
          TypeBinding[] params1=method.parameters;
          TypeBinding[] params2=method2.parameters;
          int pLength=params1.length;
          if (pLength != params2.length)           continue nextSibling;
          TypeVariableBinding[] vars=method.typeVariables;
          TypeVariableBinding[] vars2=method2.typeVariables;
          boolean equalTypeVars=vars == vars2;
          MethodBinding subMethod=method2;
          if (!equalTypeVars) {
            MethodBinding temp=method.computeSubstitutedMethod(method2,this.scope.environment());
            if (temp != null) {
              equalTypeVars=true;
              subMethod=temp;
            }
          }
          boolean equalParams=method.areParametersEqual(subMethod);
          if (equalParams && equalTypeVars) {
          }
 else           if (method.returnType.erasure() == subMethod.returnType.erasure() && (equalParams || method.areParameterErasuresEqual(method2))) {
          }
 else           if (!equalTypeVars && vars != Binding.NO_TYPE_VARIABLES && vars2 != Binding.NO_TYPE_VARIABLES) {
            continue nextSibling;
          }
 else           if (pLength > 0) {
            int index=pLength;
            for (; --index >= 0; ) {
              if (params1[index] != params2[index].erasure())               break;
              if (params1[index] == params2[index]) {
                TypeBinding type=params1[index].leafComponentType();
                if (type instanceof SourceTypeBinding && type.typeVariables() != Binding.NO_TYPE_VARIABLES) {
                  index=pLength;
                  break;
                }
              }
            }
            if (index >= 0 && index < pLength) {
              for (index=pLength; --index >= 0; )               if (params1[index].erasure() != params2[index])               break;
            }
            if (index >= 0)             continue nextSibling;
          }
        }
 else         if (!method.areParametersEqual(method2)) {
          continue nextSibling;
        }
        boolean isEnumSpecialMethod=isEnum() && (CharOperation.equals(selector,TypeConstants.VALUEOF) || CharOperation.equals(selector,TypeConstants.VALUES));
        if (methodDecl == null) {
          methodDecl=method.sourceMethod();
          if (methodDecl != null && methodDecl.binding != null) {
            if (isEnumSpecialMethod) {
              this.scope.problemReporter().duplicateEnumSpecialMethod(this,methodDecl);
            }
 else {
              this.scope.problemReporter().duplicateMethodInType(this,methodDecl,method.areParametersEqual(method2));
            }
            methodDecl.binding=null;
            if (resolvedMethods == this.methods) {
              System.arraycopy(this.methods,0,resolvedMethods=new MethodBinding[length],0,length);
            }
            resolvedMethods[i]=null;
            failed++;
          }
        }
        AbstractMethodDeclaration method2Decl=method2.sourceMethod();
        if (method2Decl != null && method2Decl.binding != null) {
          if (isEnumSpecialMethod) {
            this.scope.problemReporter().duplicateEnumSpecialMethod(this,method2Decl);
          }
 else {
            this.scope.problemReporter().duplicateMethodInType(this,method2Decl,method.areParametersEqual(method2));
          }
          method2Decl.binding=null;
          if (resolvedMethods == this.methods) {
            System.arraycopy(this.methods,0,resolvedMethods=new MethodBinding[length],0,length);
          }
          resolvedMethods[j]=null;
          failed++;
        }
      }
      if (method.returnType == null && methodDecl == null) {
        methodDecl=method.sourceMethod();
        if (methodDecl != null) {
          methodDecl.binding=null;
        }
        if (resolvedMethods == this.methods) {
          System.arraycopy(this.methods,0,resolvedMethods=new MethodBinding[length],0,length);
        }
        resolvedMethods[i]=null;
        failed++;
      }
    }
  }
  finally {
    if (failed > 0) {
      int newSize=resolvedMethods.length - failed;
      if (newSize == 0) {
        this.methods=Binding.NO_METHODS;
      }
 else {
        MethodBinding[] newMethods=new MethodBinding[newSize];
        for (int i=0, j=0, length=resolvedMethods.length; i < length; i++)         if (resolvedMethods[i] != null)         newMethods[j++]=resolvedMethods[i];
        this.methods=newMethods;
      }
    }
    addDefaultAbstractMethods();
    this.tagBits|=TagBits.AreMethodsComplete;
  }
  return this.methods;
}
