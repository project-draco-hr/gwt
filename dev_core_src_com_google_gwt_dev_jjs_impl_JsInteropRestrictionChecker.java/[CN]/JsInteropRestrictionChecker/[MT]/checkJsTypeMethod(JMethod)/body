{
  if (method.isSynthetic()) {
    return;
  }
  String jsMemberName=method.getImmediateOrTransitiveJsMemberName();
  String qualifiedMethodName=method.getQualifiedName();
  String typeName=method.getEnclosingType().getName();
  JsPropertyType jsPropertyType=method.getImmediateOrTransitiveJsPropertyType();
  if (jsMemberName == null) {
    logError("'%s' can't be exported because the method overloads multiple methods with " + "different names.",qualifiedMethodName);
  }
 else   if (jsPropertyType == JsPropertyType.HAS) {
  }
 else   if (jsPropertyType == JsPropertyType.GET) {
    if (currentJsTypeMethodNameByGetterNames.put(jsMemberName,qualifiedMethodName) != null) {
      logError("There can't be more than one getter for JsProperty '%s' in type '%s'.",jsMemberName,typeName);
    }
    checkNameCollisionForGetterAndRegular(jsMemberName,typeName);
    checkInconsistentPropertyType(jsMemberName,typeName,method.getOriginalReturnType());
  }
 else   if (jsPropertyType == JsPropertyType.SET) {
    if (currentJsTypeMethodNameBySetterNames.put(jsMemberName,qualifiedMethodName) != null) {
      logError("There can't be more than one setter for JsProperty '%s' in type '%s'.",jsMemberName,typeName);
    }
    checkNameCollisionForSetterAndRegular(jsMemberName,typeName);
    checkInconsistentPropertyType(jsMemberName,typeName,Iterables.getOnlyElement(method.getParams()).getType());
  }
 else {
    if (currentJsTypeMethodNameByMemberNames.put(jsMemberName,qualifiedMethodName) != null) {
      logError("Method '%s' can't be exported in type '%s' because the member name " + "'%s' is already taken.",qualifiedMethodName,currentType.getName(),jsMemberName);
    }
    checkNameCollisionForGetterAndRegular(jsMemberName,typeName);
    checkNameCollisionForSetterAndRegular(jsMemberName,typeName);
  }
}
