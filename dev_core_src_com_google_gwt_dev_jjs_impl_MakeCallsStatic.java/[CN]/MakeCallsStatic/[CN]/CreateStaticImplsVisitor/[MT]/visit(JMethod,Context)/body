{
  JClassType enclosingType=(JClassType)x.getEnclosingType();
  JType returnType=x.getType();
  SourceInfo sourceInfo=x.getSourceInfo();
  int myIndexInClass=enclosingType.getMethods().indexOf(x);
  assert(myIndexInClass > 0);
  String newName="$" + x.getName();
  JMethod newMethod=new JMethod(sourceInfo.makeChild(CreateStaticImplsVisitor.class,"Devirtualized function"),newName,enclosingType,returnType,false,true,true,x.isPrivate());
  newMethod.setSynthetic();
  newMethod.addThrownExceptions(x.getThrownExceptions());
  JParameter thisParam=JParameter.create(sourceInfo.makeChild(CreateStaticImplsVisitor.class,"Instance parameter"),"this$static",enclosingType.getNonNull(),true,true,newMethod);
  Map<JParameter,JParameter> varMap=new IdentityHashMap<JParameter,JParameter>();
  for (int i=0; i < x.getParams().size(); ++i) {
    JParameter oldVar=x.getParams().get(i);
    JParameter newVar=JParameter.create(oldVar.getSourceInfo(),oldVar.getName(),oldVar.getType(),oldVar.isFinal(),false,newMethod);
    varMap.put(oldVar,newVar);
  }
  List<JType> originalParamTypes=new ArrayList<JType>();
  originalParamTypes.add(enclosingType.getNonNull());
  originalParamTypes.addAll(x.getOriginalParamTypes());
  newMethod.setOriginalTypes(x.getOriginalReturnType(),originalParamTypes);
  JAbstractMethodBody movedBody=x.getBody();
  newMethod.setBody(movedBody);
  SourceInfo delegateCallSourceInfo=sourceInfo.makeChild(CreateStaticImplsVisitor.class,"Degelgating to devirtualized method");
  JMethodBody newBody=new JMethodBody(delegateCallSourceInfo);
  x.setBody(newBody);
  JMethodCall newCall=new JMethodCall(delegateCallSourceInfo,null,newMethod);
  newCall.addArg(new JThisRef(delegateCallSourceInfo,enclosingType));
  for (int i=0; i < x.getParams().size(); ++i) {
    JParameter param=x.getParams().get(i);
    newCall.addArg(new JParameterRef(delegateCallSourceInfo,param));
  }
  JStatement statement;
  if (returnType == program.getTypeVoid()) {
    statement=newCall.makeStatement();
  }
 else {
    statement=new JReturnStatement(delegateCallSourceInfo,newCall);
  }
  newBody.getBlock().addStmt(statement);
  if (newMethod.isNative()) {
    JsFunction jsFunc=((JsniMethodBody)movedBody).getFunc();
    JsName paramName=jsFunc.getScope().declareName("this$static");
    jsFunc.getParameters().add(0,new JsParameter(sourceInfo.makeChild(CreateStaticImplsVisitor.class,"Static accessor"),paramName));
    RewriteJsniMethodBody rewriter=new RewriteJsniMethodBody(paramName);
    rewriter.accept(jsFunc.getBody());
  }
 else {
    RewriteMethodBody rewriter=new RewriteMethodBody(thisParam,varMap);
    rewriter.accept(movedBody);
  }
  program.putStaticImpl(x,newMethod);
  enclosingType.getMethods().add(myIndexInClass + 1,newMethod);
  return false;
}
