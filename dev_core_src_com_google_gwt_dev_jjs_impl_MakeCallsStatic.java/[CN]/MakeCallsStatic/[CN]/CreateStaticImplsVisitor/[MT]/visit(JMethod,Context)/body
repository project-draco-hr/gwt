{
  JClassType enclosingType=(JClassType)x.getEnclosingType();
  JType returnType=x.getType();
  SourceInfo sourceInfo=x.getSourceInfo();
  int myIndexInClass=enclosingType.methods.indexOf(x);
  assert(myIndexInClass > 0);
  String newName="$" + x.getName();
  JProgram program=x.getProgram();
  JMethod newMethod=new JMethod(program,sourceInfo.makeChild(CreateStaticImplsVisitor.class,"Devirtualized function"),newName,enclosingType,returnType,false,true,true,x.isPrivate());
  JParameter thisParam=program.createParameter(sourceInfo.makeChild(CreateStaticImplsVisitor.class,"Instance parameter"),"this$static".toCharArray(),enclosingType,true,true,newMethod);
  Map<JParameter,JParameter> varMap=new IdentityHashMap<JParameter,JParameter>();
  for (int i=0; i < x.getParams().size(); ++i) {
    JParameter oldVar=x.getParams().get(i);
    JParameter newVar=program.createParameter(oldVar.getSourceInfo(),oldVar.getName().toCharArray(),oldVar.getType(),oldVar.isFinal(),false,newMethod);
    varMap.put(oldVar,newVar);
  }
  List<JType> originalParamTypes=new ArrayList<JType>();
  originalParamTypes.add(enclosingType);
  originalParamTypes.addAll(x.getOriginalParamTypes());
  newMethod.setOriginalParamTypes(originalParamTypes);
  JAbstractMethodBody movedBody=x.getBody();
  newMethod.setBody(movedBody);
  SourceInfo delegateCallSourceInfo=sourceInfo.makeChild(CreateStaticImplsVisitor.class,"Degelgating to devirtualized method");
  JMethodBody newBody=new JMethodBody(program,delegateCallSourceInfo);
  x.setBody(newBody);
  JMethodCall newCall=new JMethodCall(program,delegateCallSourceInfo,null,newMethod);
  newCall.addArg(program.getExprThisRef(delegateCallSourceInfo,enclosingType));
  for (int i=0; i < x.getParams().size(); ++i) {
    JParameter param=x.getParams().get(i);
    newCall.addArg(new JParameterRef(program,delegateCallSourceInfo,param));
  }
  JStatement statement;
  if (returnType == program.getTypeVoid()) {
    statement=newCall.makeStatement();
  }
 else {
    statement=new JReturnStatement(program,delegateCallSourceInfo,newCall);
  }
  newBody.getBlock().addStmt(statement);
  if (newMethod.isNative()) {
    JsFunction jsFunc=((JsniMethodBody)movedBody).getFunc();
    JsName paramName=jsFunc.getScope().declareName("this$static");
    jsFunc.getParameters().add(0,new JsParameter(sourceInfo.makeChild(CreateStaticImplsVisitor.class,"Static accessor"),paramName));
    RewriteJsniMethodBody rewriter=new RewriteJsniMethodBody(paramName);
    rewriter.accept(jsFunc.getBody());
  }
 else {
    RewriteMethodBody rewriter=new RewriteMethodBody(thisParam,varMap);
    rewriter.accept(movedBody);
  }
  program.putStaticImpl(x,newMethod);
  enclosingType.methods.add(myIndexInClass + 1,newMethod);
  return false;
}
