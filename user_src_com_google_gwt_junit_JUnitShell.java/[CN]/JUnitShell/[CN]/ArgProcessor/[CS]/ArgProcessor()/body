{
  super(options,true,true);
  registerHandler(new ArgHandlerPort(options){
    @Override public String[] getDefaultArgs(){
      return new String[]{"-port","auto"};
    }
  }
);
  registerHandler(new ArgHandlerPortHosted(options){
    @Override public String[] getDefaultArgs(){
      return new String[]{"-portHosted","auto"};
    }
  }
);
  registerHandler(new ArgHandlerLogLevel(options){
    @Override protected Type getDefaultLogLevel(){
      return TreeLogger.WARN;
    }
  }
);
  registerHandler(new ArgHandlerFlag(){
    @Override public String getPurpose(){
      return "Causes your test to run in -noserver hosted mode (defaults to hosted mode)";
    }
    @Override public String getTag(){
      return "-noserver";
    }
    @Override public boolean setFlag(){
      shouldAutoGenerateResources=false;
      return true;
    }
  }
);
  registerHandler(new ArgHandlerFlag(){
    @Override public String getPurpose(){
      return "Causes your test to run in web (compiled) mode (defaults to hosted mode)";
    }
    @Override public String getTag(){
      return "-web";
    }
    @Override public boolean setFlag(){
      developmentMode=false;
      return true;
    }
  }
);
  registerHandler(new ArgHandlerString(){
    @Override public String getPurpose(){
      return "Selects the runstyle to use for this test.  The name is " + "a suffix of com.google.gwt.junit.RunStyle or is a fully " + "qualified class name, and may be followed with a colon and "+ "an argument for this runstyle.";
    }
    @Override public String getTag(){
      return "-runStyle";
    }
    @Override public String[] getTagArgs(){
      return new String[]{"runstyle[:args]"};
    }
    @Override public boolean isUndocumented(){
      return false;
    }
    @Override public boolean setString(    String runStyleArg){
      String runStyleName=runStyleArg;
      String args=null;
      int colon=runStyleArg.indexOf(':');
      if (colon >= 0) {
        runStyleName=runStyleArg.substring(0,colon);
        args=runStyleArg.substring(colon + 1);
      }
      if (runStyleName.indexOf('.') < 0) {
        runStyleName=RunStyle.class.getName() + runStyleName;
      }
      Throwable caught=null;
      try {
        Class<?> clazz=Class.forName(runStyleName);
        Class<? extends RunStyle> runStyleClass=clazz.asSubclass(RunStyle.class);
        Constructor<? extends RunStyle> ctor=runStyleClass.getConstructor(JUnitShell.class);
        runStyle=ctor.newInstance(JUnitShell.this);
        return runStyle.initialize(args);
      }
 catch (      ClassNotFoundException e) {
        caught=e;
      }
catch (      SecurityException e) {
        caught=e;
      }
catch (      NoSuchMethodException e) {
        caught=e;
      }
catch (      IllegalArgumentException e) {
        caught=e;
      }
catch (      InstantiationException e) {
        caught=e;
      }
catch (      IllegalAccessException e) {
        caught=e;
      }
catch (      InvocationTargetException e) {
        caught=e;
      }
      throw new RuntimeException("Unable to create runStyle " + runStyleArg,caught);
    }
  }
);
  registerHandler(new ArgHandlerString(){
    @Override public String getPurpose(){
      return "Configure batch execution of tests";
    }
    @Override public String getTag(){
      return "-batch";
    }
    @Override public String[] getTagArgs(){
      return new String[]{"none|class|module"};
    }
    @Override public boolean isUndocumented(){
      return true;
    }
    @Override public boolean setString(    String str){
      if (str.equals("none")) {
        batchingStrategy=new NoBatchingStrategy();
      }
 else       if (str.equals("class")) {
        batchingStrategy=new ClassBatchingStrategy();
      }
 else       if (str.equals("module")) {
        batchingStrategy=new ModuleBatchingStrategy();
      }
 else {
        return false;
      }
      return true;
    }
  }
);
  registerHandler(new ArgHandlerFlag(){
    @Override public String getPurpose(){
      return "Causes the log window and browser windows to be displayed; useful for debugging";
    }
    @Override public String getTag(){
      return "-notHeadless";
    }
    @Override public boolean setFlag(){
      setHeadless(false);
      return true;
    }
  }
);
  registerHandler(new ArgHandlerString(){
    @Override public String getPurpose(){
      return "Precompile modules as tests are running (speeds up remote tests but requires more memory)";
    }
    @Override public String getTag(){
      return "-precompile";
    }
    @Override public String[] getTagArgs(){
      return new String[]{"simple|all|parallel"};
    }
    @Override public boolean isUndocumented(){
      return true;
    }
    @Override public boolean setString(    String str){
      if (str.equals("simple")) {
        compileStrategy=new SimpleCompileStrategy(JUnitShell.this);
      }
 else       if (str.equals("all")) {
        compileStrategy=new PreCompileStrategy(JUnitShell.this);
      }
 else       if (str.equals("parallel")) {
        compileStrategy=new ParallelCompileStrategy(JUnitShell.this);
      }
 else {
        return false;
      }
      return true;
    }
  }
);
  registerHandler(new ArgHandlerString(){
    @Override public String getPurpose(){
      return "Specify the user agents to reduce the number of permutations for remote browser tests;" + " e.g. ie6,ie8,safari,gecko,gecko1_8,opera";
    }
    @Override public String getTag(){
      return "-userAgents";
    }
    @Override public String[] getTagArgs(){
      return new String[]{"userAgents"};
    }
    @Override public boolean setString(    String str){
      remoteUserAgents=str.split(",");
      for (int i=0; i < remoteUserAgents.length; i++) {
        remoteUserAgents[i]=remoteUserAgents[i].trim();
      }
      return true;
    }
  }
);
}
