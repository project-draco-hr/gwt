{
  boolean originalCompilationStateRetained=options.isCompilationStateRetained();
  options.setOptimizePrecompile(false);
  for (  String moduleName : options.getModuleNames()) {
    File compilerWorkDir=options.getCompilerWorkDir(moduleName);
    Util.recursiveDelete(compilerWorkDir,true);
    compilerWorkDir.mkdirs();
    JarOutputStream precompilationJar;
    try {
      precompilationJar=new JarOutputStream(new FileOutputStream(new File(compilerWorkDir,PRECOMPILE_FILENAME)));
    }
 catch (    IOException e) {
      logger.log(TreeLogger.ERROR,"Could not create " + PRECOMPILE_FILENAME,e);
      return false;
    }
    ModuleDef module=ModuleDefLoader.loadFromClassPath(logger,moduleName);
    module.getCompilationState(logger);
    if (options.isValidateOnly()) {
      TreeLogger branch=logger.branch(TreeLogger.INFO,"Validating compilation " + module.getName());
      if (!validate(branch,options,module,options.getGenDir(),compilerWorkDir,options.getDumpSignatureFile())) {
        branch.log(TreeLogger.ERROR,"Validation failed");
        return false;
      }
      branch.log(TreeLogger.INFO,"Validation succeeded");
    }
 else {
      TreeLogger branch=logger.branch(TreeLogger.INFO,"Precompiling module " + module.getName());
      int potentialPermutations=module.getProperties().numPermutations();
      int permutationsPerIteration=options.getMaxPermsPerPrecompile();
      if (permutationsPerIteration <= 0) {
        permutationsPerIteration=potentialPermutations;
      }
      int actualPermutations=0;
      for (int potentialFirstPerm=0; potentialFirstPerm < potentialPermutations; potentialFirstPerm+=permutationsPerIteration) {
        int numPermsToPrecompile=Math.min(potentialPermutations - potentialFirstPerm,permutationsPerIteration);
        if (potentialFirstPerm != 0) {
          module.getCompilationState(branch).refresh(branch);
        }
        if (potentialFirstPerm + numPermsToPrecompile < potentialPermutations) {
          options.setCompilationStateRetained(true);
        }
 else {
          options.setCompilationStateRetained(originalCompilationStateRetained);
        }
        Precompilation precompilation=precompile(branch,options,module,actualPermutations,potentialFirstPerm,numPermsToPrecompile,options.getGenDir(),compilerWorkDir,options.getDumpSignatureFile());
        if (precompilation == null) {
          branch.log(TreeLogger.ERROR,"Precompilation failed");
          return false;
        }
        int actualNumPermsPrecompiled=precompilation.getPermutations().length;
        String precompilationFilename=PrecompilationFile.fileNameForPermutations(actualPermutations,actualNumPermsPrecompiled);
        try {
          precompilationJar.putNextEntry(new ZipEntry(precompilationFilename));
          Util.writeObjectToStream(precompilationJar,precompilation);
        }
 catch (        IOException e) {
          branch.log(TreeLogger.ERROR,"Failed to write a precompilation result",e);
          return false;
        }
        actualPermutations+=actualNumPermsPrecompiled;
        branch.log(TreeLogger.DEBUG,"Compiled " + actualNumPermsPrecompiled + " permutations starting from "+ potentialFirstPerm);
      }
      try {
        precompilationJar.close();
      }
 catch (      IOException e) {
        branch.log(TreeLogger.ERROR,"Failed to finalize " + PRECOMPILE_FILENAME,e);
        return false;
      }
      Util.writeStringAsFile(branch,new File(compilerWorkDir,PERM_COUNT_FILENAME),String.valueOf(actualPermutations));
      branch.log(TreeLogger.INFO,"Precompilation succeeded, number of permutations: " + actualPermutations);
    }
  }
  return true;
}
