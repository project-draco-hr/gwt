{
  PerfLogger.start("TypeOracleMediator.addNewUnits");
  classMap=new HashMap<String,CollectClassData>();
  for (  CompilationUnit unit : units) {
    if (!unit.isCompiled()) {
      continue;
    }
    Collection<CompiledClass> compiledClasses=unit.getCompiledClasses();
    for (    CompiledClass compiledClass : compiledClasses) {
      CollectClassData cv=processClass(compiledClass);
      if (!cv.hasNoExternalName()) {
        classMap.put(compiledClass.getInternalName(),cv);
      }
    }
  }
  classMapType=new HashMap<JRealClassType,CollectClassData>();
  Set<JRealClassType> unresolvedTypes=new HashSet<JRealClassType>();
  for (  CompilationUnit unit : units) {
    if (!unit.isCompiled()) {
      continue;
    }
    Collection<CompiledClass> compiledClasses=unit.getCompiledClasses();
    for (    CompiledClass compiledClass : compiledClasses) {
      String internalName=compiledClass.getInternalName();
      CollectClassData cv=classMap.get(internalName);
      if (cv == null) {
        continue;
      }
      JRealClassType type=createType(compiledClass,unresolvedTypes);
      if (type != null) {
        if (unit instanceof SourceFileCompilationUnit) {
          SourceFileCompilationUnit sourceUnit=(SourceFileCompilationUnit)unit;
          Resource sourceFile=sourceUnit.getSourceFile();
          typeOracle.addSourceReference(type,sourceFile);
        }
        binaryMapper.put(internalName,type);
        classMapType.put(type,cv);
      }
    }
  }
  TreeLogger branch=logger.branch(TreeLogger.SPAM,"Resolving enclosing classes");
  for (Iterator<JRealClassType> it=unresolvedTypes.iterator(); it.hasNext(); ) {
    JRealClassType type=it.next();
    if (!resolveEnclosingClass(branch,type)) {
      it.remove();
    }
  }
  for (  JRealClassType type : unresolvedTypes) {
    branch=logger.branch(TreeLogger.SPAM,"Resolving " + type.getQualifiedSourceName());
    if (!resolveClass(branch,type)) {
    }
  }
  typeOracle.finish();
  classMap=null;
  classMapType=null;
  PerfLogger.end();
}
