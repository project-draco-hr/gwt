{
  if (!decelerating) {
    return;
  }
  double now=Duration.currentTimeMillis();
  double framesExpected=Math.floor((now - startTime) / MS_PER_FRAME);
  do {
    stepWithoutAnimation();
  }
 while (isVelocityAboveThreshold(DECELERATION_STOP_VELOCITY) && (!isStepNecessary() || framesExpected > stepNumber));
  double floorY=currentOffset.y;
  double floorX=currentOffset.x;
  if (decelerating) {
    delegate.onDecelerate(floorX,floorY,velocity);
    previousOffset.y=floorY;
    previousOffset.x=floorX;
  }
  if (!isBouncing() && !isVelocityAboveThreshold(DECELERATION_STOP_VELOCITY)) {
    stop();
    return;
  }
  stepFunction.schedule((int)(MS_PER_FRAME * (1 + stepNumber - framesExpected)));
}
