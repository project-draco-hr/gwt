{
  this.defaultPageSize=pageSize;
  this.nodeView=nodeView;
  final Cell<C> cell=nodeInfo.getCell();
  impl=new CellListImpl<C>(this,pageSize,nodeView.ensureChildContainer()){
    @Override public void setData(    List<C> values,    int start){
      nodeView.updateImage(false);
      if (nodeView.children == null) {
        nodeView.children=new ArrayList<CellTreeNodeView<?>>();
      }
      int len=values.size();
      int end=start + len;
      int childCount=nodeView.getChildCount();
      Map<Object,CellTreeNodeView<?>> openNodes=new HashMap<Object,CellTreeNodeView<?>>();
      for (int i=start; i < end && i < childCount; i++) {
        CellTreeNodeView<?> child=nodeView.getChildNode(i);
        if (child.isOpen()) {
          openNodes.put(child.getValueKey(),child);
        }
      }
      if (nodeView.tree.isAnimationEnabled()) {
        nodeView.ensureAnimationFrame().getStyle().setDisplay(Display.NONE);
      }
      ProvidesKey<C> providesKey=nodeInfo.getProvidesKey();
      savedViews=new HashMap<Object,CellTreeNodeView<?>>();
      for (      C childValue : values) {
        Object key=providesKey.getKey(childValue);
        CellTreeNodeView<?> savedView=openNodes.remove(key);
        if (savedView != null) {
          savedView.ensureAnimationFrame().removeFromParent();
          savedViews.put(key,savedView);
        }
      }
      super.setData(values,start);
      Element childElem=nodeView.ensureChildContainer().getFirstChildElement();
      for (int i=start; i < end; i++) {
        C childValue=values.get(i - start);
        CellTreeNodeView<C> child=nodeView.createTreeNodeView(nodeInfo,childElem,childValue,null);
        CellTreeNodeView<?> savedChild=savedViews.remove(providesKey.getKey(childValue));
        if (savedChild != null) {
          child.animationFrame=savedChild.animationFrame;
          child.contentContainer=savedChild.contentContainer;
          child.childContainer=savedChild.childContainer;
          child.children=savedChild.children;
          child.emptyMessageElem=savedChild.emptyMessageElem;
          child.nodeInfo=savedChild.nodeInfo;
          child.nodeInfoLoaded=savedChild.nodeInfoLoaded;
          child.open=savedChild.open;
          child.showMoreElem=savedChild.showMoreElem;
          savedChild.listView.setNodeView(child);
          child.getElement().appendChild(savedChild.ensureAnimationFrame());
        }
        if (childCount > i) {
          if (savedChild == null) {
            nodeView.children.get(i).cleanup();
          }
          nodeView.children.set(i,child);
        }
 else {
          nodeView.children.add(child);
        }
        childElem=childElem.getNextSiblingElement();
      }
      savedViews=null;
      if (nodeView.tree.isAnimationEnabled()) {
        nodeView.tree.maybeAnimateTreeNode(nodeView);
      }
    }
    @Override protected boolean dependsOnSelection(){
      return cell.dependsOnSelection();
    }
    @Override protected void emitHtml(    StringBuilder sb,    List<C> values,    int start,    SelectionModel<? super C> selectionModel){
      CellTree.Style style=nodeView.tree.getStyle();
      String selectedStyle=style.selectedItem();
      String itemStyle=style.item();
      String itemImageValueStyle=style.itemImageValue();
      String itemValueStyle=style.itemValue();
      String openStyle=style.openItem();
      String topStyle=style.topItem();
      String topImageValueStyle=style.topItemImageValue();
      boolean isRootNode=nodeView.isRootNode();
      String openImage=nodeView.tree.getOpenImageHtml(isRootNode);
      String closedImage=nodeView.tree.getClosedImageHtml(isRootNode);
      int imageWidth=nodeView.tree.getImageWidth();
      int paddingLeft=imageWidth * nodeView.depth;
      ProvidesKey<C> providesKey=nodeInfo.getProvidesKey();
      TreeViewModel model=nodeView.tree.getTreeViewModel();
      for (      C value : values) {
        Object key=providesKey.getKey(value);
        boolean isOpen=savedViews.containsKey(key);
        sb.append("<div>");
        sb.append("<div style='padding-left:");
        sb.append(paddingLeft);
        sb.append("px;' class='").append(itemStyle);
        if (isOpen) {
          sb.append(" ").append(openStyle);
        }
        if (isRootNode) {
          sb.append(" ").append(topStyle);
        }
        if (selectionModel != null && selectionModel.isSelected(value)) {
          sb.append(" ").append(selectedStyle);
        }
        sb.append("'>");
        sb.append("<div onclick='' style='position:relative;padding-left:");
        sb.append(imageWidth);
        sb.append("px;' class='").append(itemImageValueStyle);
        if (isRootNode) {
          sb.append(" ").append(topImageValueStyle);
        }
        sb.append("'>");
        if (isOpen) {
          sb.append(openImage);
        }
 else         if (model.isLeaf(value)) {
          sb.append(LEAF_IMAGE);
        }
 else {
          sb.append(closedImage);
        }
        sb.append("<div class='").append(itemValueStyle).append("'>");
        cell.render(value,null,sb);
        sb.append("</div></div></div></div>");
      }
    }
    @Override protected void removeLastItem(){
      CellTreeNodeView<?> child=nodeView.children.remove(nodeView.children.size() - 1);
      child.cleanup();
      super.removeLastItem();
    }
    @Override protected void setSelected(    Element elem,    boolean selected){
      setStyleName(getSelectionElement(elem),nodeView.tree.getStyle().selectedItem(),selected);
    }
  }
;
  impl.setPager(new Pager<C>(){
    public void onRangeOrSizeChanged(    PagingListView<C> listView){
      int dataSize=impl.getDataSize();
      showOrHide(nodeView.showMoreElem,dataSize > impl.getPageSize());
      if (dataSize == 0) {
        showOrHide(nodeView.emptyMessageElem,true);
        nodeView.updateImage(false);
      }
 else {
        showOrHide(nodeView.emptyMessageElem,false);
      }
    }
  }
);
}
