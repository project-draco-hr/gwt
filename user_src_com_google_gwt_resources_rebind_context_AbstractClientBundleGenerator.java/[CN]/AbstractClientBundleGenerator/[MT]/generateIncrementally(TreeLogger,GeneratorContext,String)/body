{
  boolean useCache=false;
  if (checkCachedPropertyInformation(logger,generatorContext) && checkCachedSourceTypes(logger,generatorContext) && checkCachedDependentResources(logger,generatorContext)) {
    useCache=true;
  }
  if (logger.isLoggable(TreeLogger.TRACE)) {
    if (generatorContext.isGeneratorResultCachingEnabled()) {
      String msg;
      if (useCache) {
        msg="Reusing cached client bundle for " + typeName;
      }
 else {
        msg="Can't use cached client bundle for " + typeName;
      }
      logger.log(TreeLogger.TRACE,msg);
    }
  }
  if (useCache) {
    return new RebindResult(RebindMode.USE_ALL_CACHED,typeName);
  }
  TypeOracle typeOracle=generatorContext.getTypeOracle();
  JClassType sourceType=typeOracle.findType(typeName);
  if (sourceType == null) {
    logger.log(TreeLogger.ERROR,"Could not find requested typeName");
    throw new UnableToCompleteException();
  }
 else   if (sourceType.isInterface() == null) {
    logger.log(TreeLogger.ERROR,sourceType.getQualifiedSourceName() + " is not an interface.",null);
    throw new UnableToCompleteException();
  }
  Map<Class<? extends ResourceGenerator>,List<JMethod>> taskList=createTaskList(logger,typeOracle,sourceType);
  boolean canBeCacheable=checkResourceGeneratorCacheability(generatorContext,taskList);
  AbstractResourceContext resourceContext=createResourceContext(logger,generatorContext,sourceType);
  FieldsImpl fields=new FieldsImpl();
  RequirementsImpl requirements=new RequirementsImpl(generatorContext.getPropertyOracle(),canBeCacheable);
  resourceContext.setRequirements(requirements);
  doAddFieldsAndRequirements(logger,generatorContext,fields,requirements);
  requirements.addTypeHierarchy(sourceType);
  Map<ResourceGenerator,List<JMethod>> generators=initAndPrepare(logger,taskList,resourceContext,requirements);
  String generatedSimpleSourceName=generateSimpleSourceName(logger,resourceContext,requirements);
  String packageName=sourceType.getPackage().getName();
  String createdClassName=packageName + "." + generatedSimpleSourceName;
  PrintWriter out=generatorContext.tryCreate(logger,packageName,generatedSimpleSourceName);
  if (out != null) {
    doCreateBundleForPermutation(logger,generatorContext,fields,generatedSimpleSourceName);
    ClassSourceFileComposerFactory f=new ClassSourceFileComposerFactory(packageName,generatedSimpleSourceName);
    f.addImport(GWT.class.getName());
    f.addImport(ResourcePrototype.class.getName());
    f.addImplementedInterface(sourceType.getQualifiedSourceName());
    SourceWriter sw=f.createSourceWriter(generatorContext,out);
    resourceContext.setSimpleSourceName(generatedSimpleSourceName);
    JParameterizedType hashMapStringResource=getHashMapStringResource(typeOracle);
    String resourceMapField=fields.define(hashMapStringResource,"resourceMap");
    sw.print("private static " + generatedSimpleSourceName + " ");
    sw.println(INSTANCE_NAME + " = new " + generatedSimpleSourceName+ "();");
    createFieldsAndAssignments(logger,sw,generators,resourceContext,fields);
    sw.println(fields.getCode());
    taskList.remove(BundleResourceGenerator.class);
    writeMapMethods(sw,taskList,hashMapStringResource,resourceMapField);
    sw.commit(logger);
  }
  finish(logger,resourceContext,generators.keySet());
  doFinish(logger);
  if (canBeCacheable) {
    CachedPropertyInformation cpi=new CachedPropertyInformation(logger,generatorContext.getPropertyOracle(),requirements.getPermutationAxes(),requirements.getConfigurationPropertyNames());
    Map<String,Long> cti=requirements.getTypeLastModifiedTimes();
    Map<String,URL> cri=requirements.getResolvedResources();
    RebindResult result=new RebindResult(RebindMode.USE_ALL_NEW,createdClassName);
    result.putClientData(CACHED_PROPERTY_INFORMATION,cpi);
    result.putClientData(CACHED_RESOURCE_INFORMATION,(Serializable)cri);
    result.putClientData(CACHED_TYPE_INFORMATION,(Serializable)cti);
    return result;
  }
 else {
    return new RebindResult(RebindMode.USE_ALL_NEW_WITH_NO_CACHING,createdClassName);
  }
}
