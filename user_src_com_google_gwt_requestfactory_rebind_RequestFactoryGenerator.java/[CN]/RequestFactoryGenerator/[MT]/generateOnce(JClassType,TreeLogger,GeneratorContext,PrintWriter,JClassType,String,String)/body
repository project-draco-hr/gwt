{
  logger=logger.branch(TreeLogger.DEBUG,String.format("Generating implementation of %s",interfaceType.getName()));
  ClassSourceFileComposerFactory f=new ClassSourceFileComposerFactory(packageName,implName);
  f.addImport(HandlerManager.class.getName());
  f.addImport(RequestFactoryJsonImpl.class.getName());
  f.addImport(interfaceType.getQualifiedSourceName());
  f.addImport(RecordToTypeMap.class.getName());
  f.addImport(Record.class.getName());
  f.addImport(RecordSchema.class.getName());
  f.addImplementedInterface(interfaceType.getName());
  f.setSuperclass(RequestFactoryJsonImpl.class.getSimpleName());
  SourceWriter sw=f.createSourceWriter(generatorContext,out);
  sw.println();
  Set<JMethod> requestSelectors=new LinkedHashSet<JMethod>();
  for (  JMethod method : interfaceType.getOverridableMethods()) {
    if (method.getEnclosingType().equals(requestFactoryType)) {
      continue;
    }
    JType returnType=method.getReturnType();
    if (null == returnType) {
      logger.log(TreeLogger.ERROR,String.format("Illegal return type for %s. Methods of %s must return interfaces, found void",method.getName(),interfaceType.getName()));
      throw new UnableToCompleteException();
    }
    JClassType asInterface=returnType.isInterface();
    if (null == asInterface) {
      logger.log(TreeLogger.ERROR,String.format("Illegal return type for %s. Methods of %s must return interfaces",method.getName(),interfaceType.getName()));
      throw new UnableToCompleteException();
    }
    requestSelectors.add(method);
  }
  JClassType t=generatorContext.getTypeOracle().findType(RequestFactory.class.getName());
  try {
    requestSelectors.add(t.getMethod("loggingRequest",new JType[0]));
  }
 catch (  NotFoundException e) {
    e.printStackTrace();
  }
  JClassType recordToTypeInterface=generatorContext.getTypeOracle().findType(RecordToTypeMap.class.getName());
  String recordToTypeMapName=recordToTypeInterface.getName() + "Impl";
  sw.println("public " + Record.class.getName() + " create(Class token) {");
  sw.indent();
  sw.println("return create(token, new " + recordToTypeMapName + "());");
  sw.outdent();
  sw.println("}");
  sw.println();
  sw.println("public Class<? extends " + Record.class.getName() + "> getClass(String token) {");
  sw.indent();
  sw.println("return getClass(token, new " + recordToTypeMapName + "());");
  sw.outdent();
  sw.println("}");
  sw.println();
  sw.println("public " + Record.class.getName() + " getProxy(String token) {");
  sw.indent();
  sw.println("return getProxy(token, new " + recordToTypeMapName + "());");
  sw.outdent();
  sw.println("}");
  sw.println();
  sw.println("public String getToken(Class clazz) {");
  sw.indent();
  sw.println("return getToken(clazz, new " + recordToTypeMapName + "());");
  sw.outdent();
  sw.println("}");
  sw.println();
  sw.println("public RecordSchema<? extends Record> getSchema(String schemaToken) {");
  sw.indent();
  sw.println("return new " + recordToTypeMapName + "().getType(schemaToken);");
  sw.outdent();
  sw.println("}");
  for (  JMethod requestSelector : requestSelectors) {
    String returnTypeName=requestSelector.getReturnType().getQualifiedSourceName();
    String nestedImplName=capitalize(requestSelector.getName().replace('.','_')) + "Impl";
    String nestedImplPackage=generatorContext.getTypeOracle().findType(returnTypeName).getPackage().getName();
    sw.println("public " + returnTypeName + " "+ requestSelector.getName()+ "() {");
    sw.indent();
    sw.println("return new " + nestedImplPackage + "."+ nestedImplName+ "(this);");
    sw.outdent();
    sw.println("}");
    sw.println();
    PrintWriter pw=generatorContext.tryCreate(logger,nestedImplPackage,nestedImplName);
    if (pw != null) {
      generateRequestSelectorImplementation(logger,generatorContext,pw,requestSelector,interfaceType,nestedImplPackage,nestedImplName);
    }
  }
  sw.outdent();
  sw.println("}");
  PrintWriter pw=generatorContext.tryCreate(logger,packageName,recordToTypeMapName);
  if (pw != null) {
    generateRecordToTypeMap(logger,generatorContext,pw,recordToTypeInterface,packageName,recordToTypeMapName);
  }
  generatorContext.commit(logger,out);
}
