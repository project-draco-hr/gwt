{
  TypeOracle typeOracle=generatorContext.getTypeOracle();
  if (!publicRecordType.isAssignableTo(typeOracle.findType(Record.class.getName()))) {
    return;
  }
  if (generatedRecordTypes.contains(publicRecordType)) {
    return;
  }
  String recordImplTypeName=publicRecordType.getName() + "Impl";
  PrintWriter pw=generatorContext.tryCreate(logger,packageName,recordImplTypeName);
  if (pw != null) {
    logger=logger.branch(TreeLogger.DEBUG,"Generating " + publicRecordType.getName());
    ClassSourceFileComposerFactory f=new ClassSourceFileComposerFactory(packageName,recordImplTypeName);
    String eventTypeName=publicRecordType.getName() + "Changed";
    JClassType eventType=typeOracle.findType(packageName,eventTypeName);
    if (eventType == null) {
      logger.log(TreeLogger.ERROR,String.format("Cannot find %s implementation %s.%s",RecordChangedEvent.class.getName(),packageName,eventTypeName));
      throw new UnableToCompleteException();
    }
    f.addImport(AbstractJsonListRequest.class.getName());
    f.addImport(AbstractJsonObjectRequest.class.getName());
    f.addImport(RequestFactoryJsonImpl.class.getName());
    f.addImport(Property.class.getName());
    f.addImport(Record.class.getName());
    f.addImport(RecordImpl.class.getName());
    f.addImport(RecordJsoImpl.class.getName());
    f.addImport(RecordSchema.class.getName());
    f.addImport(WriteOperation.class.getName().replace("$","."));
    f.addImport(Collections.class.getName());
    f.addImport(HashSet.class.getName());
    f.addImport(Set.class.getName());
    f.setSuperclass(RecordImpl.class.getSimpleName());
    f.addImplementedInterface(publicRecordType.getName());
    SourceWriter sw=f.createSourceWriter(generatorContext,pw);
    sw.println();
    JClassType propertyType=printSchema(typeOracle,publicRecordType,recordImplTypeName,eventType,sw);
    sw.println();
    String simpleImplName=publicRecordType.getSimpleSourceName() + "Impl";
    printRequestImplClass(sw,publicRecordType,simpleImplName,true);
    printRequestImplClass(sw,publicRecordType,simpleImplName,false);
    sw.println();
    sw.println(String.format("public static final RecordSchema<%s> SCHEMA = new MySchema();",recordImplTypeName));
    sw.println();
    sw.println(String.format("private %s(RecordJsoImpl jso, boolean isFuture) {",recordImplTypeName));
    sw.indent();
    sw.println("super(jso, isFuture);");
    sw.outdent();
    sw.println("}");
    for (    JField field : publicRecordType.getFields()) {
      JType fieldType=field.getType();
      if (propertyType.getErasedType() == fieldType.getErasedType()) {
        JParameterizedType parameterized=fieldType.isParameterized();
        if (parameterized == null) {
          logger.log(TreeLogger.ERROR,fieldType + " must have its param type set.");
          throw new UnableToCompleteException();
        }
        JClassType returnType=parameterized.getTypeArgs()[0];
        sw.println();
        sw.println(String.format("public %s get%s() {",returnType.getQualifiedSourceName(),capitalize(field.getName())));
        sw.indent();
        sw.println(String.format("return get(%s);",field.getName()));
        sw.outdent();
        sw.println("}");
      }
    }
    for (    JField field : publicRecordType.getFields()) {
      JType fieldType=field.getType();
      if (propertyType.getErasedType() == fieldType.getErasedType()) {
        JParameterizedType parameterized=fieldType.isParameterized();
        if (parameterized == null) {
          logger.log(TreeLogger.ERROR,fieldType + " must have its param type set.");
          throw new UnableToCompleteException();
        }
        JClassType returnType=parameterized.getTypeArgs()[0];
        sw.println();
        String varName=field.getName();
        sw.println(String.format("public void set%s(%s %s) {",capitalize(field.getName()),returnType.getQualifiedSourceName(),varName));
        sw.indent();
        sw.println(String.format("set(this.%s, this, %s);",field.getName(),varName));
        sw.outdent();
        sw.println("}");
      }
    }
    sw.outdent();
    sw.println("}");
    generatorContext.commit(logger,pw);
  }
  generatedRecordTypes.add(publicRecordType);
}
