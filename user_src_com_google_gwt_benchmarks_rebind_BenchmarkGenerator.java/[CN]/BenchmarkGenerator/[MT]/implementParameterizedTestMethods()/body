{
  Map<String,JMethod> parameterizedMethods=getParameterizedTestMethods(getRequestedClass(),logger);
  SourceWriter sw=getSourceWriter();
  JClassType type=getRequestedClass();
  for (  Map.Entry<String,JMethod> entry : parameterizedMethods.entrySet()) {
    String name=entry.getKey();
    JMethod method=entry.getValue();
    JMethod beginMethod=getBeginMethod(type,method);
    JMethod endMethod=getEndMethod(type,method);
    sw.println("public void " + name + "() {");
    sw.indent();
    sw.println("  privateDelayTestFinish( 2000 );");
    sw.println();
    MutableLong bound=new MutableLong();
    Map<String,String> metaDataByParams=getParamMetaData(method,bound);
    validateParams(method,metaDataByParams);
    JParameter[] methodParams=method.getParameters();
    List<String> paramNames=new ArrayList<String>(methodParams.length);
    for (int i=0; i < methodParams.length; ++i) {
      paramNames.add(methodParams[i].getName());
    }
    sw.print("final java.util.List<Iterable<?>> iterables = java.util.Arrays.asList( new Iterable<?>[] { ");
    for (int i=0; i < paramNames.size(); ++i) {
      String paramName=paramNames.get(i);
      sw.print(ITERABLE_ADAPTER_CLASS + ".toIterable(" + metaDataByParams.get(paramName)+ ")");
      if (i != paramNames.size() - 1) {
        sw.print(",");
      }
 else {
        sw.println("} );");
      }
      sw.print(" ");
    }
    sw.println("final " + PERMUTATION_ITERATOR_CLASS + " permutationIt = new "+ PERMUTATION_ITERATOR_CLASS+ "(iterables);\n"+ DeferredCommand.class.getName()+ ".addCommand( new "+ IncrementalCommand.class.getName()+ "() {\n"+ "  public boolean execute() {\n"+ "    privateDelayTestFinish( 10000 );\n"+ "    if ( permutationIt.hasNext() ) {\n"+ "      "+ PERMUTATION_ITERATOR_CLASS+ ".Permutation permutation = permutationIt.next();\n");
    for (int i=0; i < methodParams.length; ++i) {
      JParameter methodParam=methodParams[i];
      String typeName=methodParam.getType().getQualifiedSourceName();
      String paramName=paramNames.get(i);
      sw.println("      " + typeName + " "+ paramName+ " = ("+ typeName+ ") permutation.getValues().get("+ i+ ");");
    }
    final String setupTimingName="__setupTiming";
    final String testTimingName="__testTiming";
    sw.println("double " + setupTimingName + " = 0;");
    sw.println("double " + testTimingName + " = 0;");
    Statements setupBench=genBenchTarget(beginMethod,endMethod,paramNames,new Statement(new MethodCall(EMPTY_FUNC,null)));
    Statements testBench=genBenchTarget(beginMethod,endMethod,paramNames,new Statement(new MethodCall(method.getName(),paramNames)));
    StringBuffer recordResultsCode=new StringBuffer(BENCHMARK_RESULTS_CLASS + " results = __getOrCreateTestResult();\n" + TRIAL_CLASS+ " trial = new "+ TRIAL_CLASS+ "();\n"+ "trial.setRunTimeMillis( "+ testTimingName+ " - "+ setupTimingName+ " );\n"+ "java.util.Map<String, String> variables = trial.getVariables();\n");
    for (    String paramName : paramNames) {
      recordResultsCode.append("variables.put( \"").append(paramName).append("\", ").append(paramName).append(".toString() );\n");
    }
    recordResultsCode.append("results.getTrials().add( trial )");
    Statements recordCode=new Statement(recordResultsCode.toString());
    Statements breakCode=new Statement("  permutationIt.skipCurrentRange()");
    setupBench=benchmark(setupBench,setupTimingName,0,null,breakCode);
    testBench=benchmark(testBench,testTimingName,bound.value,recordCode,breakCode);
    Statements testAndSetup=new StatementsList();
    testAndSetup.getStatements().addAll(setupBench.getStatements());
    testAndSetup.getStatements().addAll(testBench.getStatements());
    sw.println(testAndSetup.toString());
    sw.println("      return true;\n" + "    }\n" + "    privateFinishTest();\n"+ "    return false;\n"+ "  }\n"+ "} );\n");
    sw.outdent();
    sw.println("}");
  }
}
