{
  if (isZero(b)) {
    throw new ArithmeticException("divide by zero");
  }
  if (isZero(a)) {
    if (computeRemainder) {
      remainder=create();
    }
    return create();
  }
  if (isMinValue(b)) {
    return divModByMinValue(a,computeRemainder);
  }
  boolean negative=false;
  if (isNegative(b)) {
    b=LongLib.neg(b);
    negative=!negative;
  }
  int bpower=powerOfTwo(b);
  boolean aIsNegative=false;
  boolean aIsMinValue=false;
  boolean aIsCopy=false;
  if (isMinValue(a)) {
    aIsMinValue=true;
    aIsNegative=true;
    if (bpower == -1) {
      a=create(LongLib.Const.MAX_VALUE);
      aIsCopy=true;
      negative=!negative;
    }
 else {
      LongEmul c=LongLib.shr(a,bpower);
      if (negative) {
        negate(c);
      }
      if (computeRemainder) {
        remainder=create();
      }
      return c;
    }
  }
 else   if (isNegative(a)) {
    aIsNegative=true;
    a=LongLib.neg(a);
    aIsCopy=true;
    negative=!negative;
  }
  if (bpower != -1) {
    return divModByShift(a,bpower,negative,aIsNegative,computeRemainder);
  }
  if (LongLib.lt(a,b)) {
    if (computeRemainder) {
      if (aIsNegative) {
        remainder=LongLib.neg(a);
      }
 else {
        remainder=create(a);
      }
    }
    return create();
  }
  return divModHelper(aIsCopy ? a : create(a),b,negative,aIsNegative,aIsMinValue,computeRemainder);
}
