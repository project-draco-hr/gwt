{
  boolean hasBackRef=hasBackRef(x);
  if (hasBackRef && isStarted(x)) {
    push(makeBackRef(x));
    return false;
  }
  byte[] currentBackRef=begin(x);
  push(constructorFunction(x));
  lparen();
  if (hasBackRef) {
    push(currentBackRef);
    eq();
  }
  lbracket();
  for (Iterator<ValueCommand> it=x.getComponentValues().iterator(); it.hasNext(); ) {
    accept(it.next());
    if (it.hasNext()) {
      comma();
    }
  }
  rbracket();
  rparen();
  commit(x,false);
  if (!hasBackRef) {
    forget(x);
  }
  return false;
}
