{
  String recordImplTypeName=publicRecordType.getName() + "Impl";
  PrintWriter pw=printWriters.tryToMakePrintWriterFor(recordImplTypeName);
  if (pw != null) {
    logger=logger.branch(TreeLogger.INFO,"Generating " + publicRecordType.getName());
    ClassSourceFileComposerFactory f=new ClassSourceFileComposerFactory(packageName,recordImplTypeName);
    String eventTypeName=publicRecordType.getName() + "Changed";
    JClassType eventType=typeOracle.findType(packageName,eventTypeName);
    if (eventType == null) {
      logger.log(TreeLogger.ERROR,String.format("Cannot find %s implementation %s.%s",RecordChangedEvent.class.getName(),packageName,eventTypeName));
      throw new UnableToCompleteException();
    }
    f.addImport(Property.class.getName());
    f.addImport(Record.class.getName());
    f.addImport(RecordImpl.class.getName());
    f.addImport(RecordJsoImpl.class.getName());
    f.addImport(RecordSchema.class.getName());
    f.addImport(Collections.class.getName());
    f.addImport(HashSet.class.getName());
    f.addImport(Set.class.getName());
    f.setSuperclass(RecordImpl.class.getSimpleName());
    f.addImplementedInterface(publicRecordType.getName());
    SourceWriter sw=f.createSourceWriter(generatorContext,pw);
    sw.println();
    sw.println(String.format("public static class MySchema extends RecordSchema<%s> {",recordImplTypeName));
    sw.indent();
    sw.println("private final Set<Property<?>> allProperties;");
    sw.println("{");
    sw.indent();
    sw.println("Set<Property<?>> set = new HashSet<Property<?>>();");
    sw.println("set.addAll(super.allProperties());");
    JClassType propertyType;
    try {
      propertyType=typeOracle.getType(Property.class.getName());
    }
 catch (    NotFoundException e) {
      throw new RuntimeException(e);
    }
    for (    JField field : publicRecordType.getFields()) {
      if (propertyType.getErasedType() == field.getType().getErasedType()) {
        sw.println(String.format("set.add(%s);",field.getName()));
      }
    }
    sw.println("allProperties = Collections.unmodifiableSet(set);");
    sw.outdent();
    sw.println("}");
    sw.println();
    sw.println("public Set<Property<?>> allProperties() {");
    sw.indent();
    sw.println("return allProperties;");
    sw.outdent();
    sw.println("}");
    sw.println();
    sw.println("@Override");
    sw.println(String.format("public %s create(RecordJsoImpl jso) {",recordImplTypeName));
    sw.indent();
    sw.println(String.format("return new %s(jso);",recordImplTypeName));
    sw.outdent();
    sw.println("}");
    sw.println();
    sw.println("@Override");
    sw.println(String.format("public %s createChangeEvent(Record record) {",eventType.getName()));
    sw.indent();
    sw.println(String.format("return new %s((%s) record);",eventType.getName(),publicRecordType.getName()));
    sw.outdent();
    sw.println("}");
    sw.outdent();
    sw.println("}");
    sw.println();
    sw.println(String.format("public static final RecordSchema<%s> SCHEMA = new MySchema();",recordImplTypeName));
    sw.println();
    sw.println(String.format("private %s(RecordJsoImpl jso) {",recordImplTypeName));
    sw.indent();
    sw.println("super(jso);");
    sw.outdent();
    sw.println("}");
    for (    JField field : publicRecordType.getFields()) {
      JType fieldType=field.getType();
      if (propertyType.getErasedType() == fieldType.getErasedType()) {
        JParameterizedType parameterized=fieldType.isParameterized();
        if (parameterized == null) {
          logger.log(TreeLogger.ERROR,fieldType + " must have its param type set.");
          throw new UnableToCompleteException();
        }
        JClassType returnType=parameterized.getTypeArgs()[0];
        sw.println();
        sw.println(String.format("public %s get%s() {",returnType.getQualifiedSourceName(),capitalize(field.getName())));
        sw.indent();
        sw.println(String.format("return get(%s);",field.getName()));
        sw.outdent();
        sw.println("}");
      }
    }
    sw.outdent();
    sw.println("}");
  }
  return recordImplTypeName;
}
