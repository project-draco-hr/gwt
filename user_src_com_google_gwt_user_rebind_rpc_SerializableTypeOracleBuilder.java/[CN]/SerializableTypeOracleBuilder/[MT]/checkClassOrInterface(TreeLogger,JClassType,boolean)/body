{
  JClassType superclass=type.getSuperclass();
  if (superclass != null) {
    MetaTypeInfo superMti=getMetaTypeInfo(superclass);
    if (superMti.qualifiesForSerialization()) {
      checkType(logger.branch(TreeLogger.DEBUG,"Analyzing superclass:",null),superclass,false);
    }
 else {
      logger.branch(TreeLogger.DEBUG,"Not analyzing superclass '" + superclass.getParameterizedQualifiedSourceName() + "' because it is not assignable to '"+ IsSerializable.class.getName()+ "' or '"+ Serializable.class.getName()+ "' nor does it have a custom field serializer",null);
    }
  }
  MetaTypeInfo mti=getMetaTypeInfo(type);
  if (mti.qualifiesForSerialization()) {
    if (mti.qualifiesForManualSerialization()) {
      List failures=CustomFieldSerializerValidator.validate(streamReaderClass,streamWriterClass,mti.getManualSerializer(),type);
      if (!failures.isEmpty()) {
        validationFailed=true;
        markAsUnserializableAndLog(logger,TreeLogger.ERROR,failures,mti);
        return;
      }
    }
 else {
      if (!mti.directlyImplementsMarkerInterface()) {
        if (superclass != null && !getMetaTypeInfo(superclass).isSerializable()) {
          markAsUnserializableAndLog(logger,TreeLogger.WARN,"Superclass '" + superclass.getQualifiedSourceName() + "' is not serializable and this type does not implement '"+ IsSerializable.class.getName()+ "' or '"+ Serializable.class.getName()+ "'; see previous log entries",mti);
          return;
        }
      }
      if (type.isLocalType()) {
        markAsUnserializableAndLog(logger,TreeLogger.WARN,"Is a local type, it will be excluded from the set of serializable types",mti);
        return;
      }
      if (type.isMemberType() && !type.isStatic()) {
        markAsUnserializableAndLog(logger,TreeLogger.WARN,"Is nested but not static, it will be excluded from the set of serializable types",mti);
        return;
      }
      if (type.isClass() != null && !type.isAbstract() && !type.isDefaultInstantiable()) {
        markAsUnserializableAndLog(logger,TreeLogger.WARN,"Was not default instantiable (it must have a zero-argument, public constructor or no constructors at all)",mti);
        return;
      }
    }
    mti.setSerializable(true);
    checkFields(logger,type);
    checkMethods(logger,type);
  }
 else {
    logger.branch(TreeLogger.DEBUG,"Type '" + type.getParameterizedQualifiedSourceName() + "' is not assignable to '"+ IsSerializable.class.getName()+ "' or '"+ Serializable.class.getName()+ "' nor does it have a custom field serializer",null);
  }
  if (checkSubtypes) {
    JClassType[] subtypes=type.getSubtypes();
    if (subtypes.length > 0) {
      TreeLogger localLogger=logger.branch(TreeLogger.DEBUG,"Analyzing subclasses:",null);
      for (int i=0; i < subtypes.length; ++i) {
        JClassType subtype=subtypes[i];
        MetaTypeInfo smti=getMetaTypeInfo(subtype);
        if (smti.qualifiesForSerialization()) {
          checkType(localLogger,subtype,false);
        }
 else {
          localLogger.branch(TreeLogger.DEBUG,"Not analyzing subclass '" + subtype.getParameterizedQualifiedSourceName() + "' because it is not assignable to '"+ IsSerializable.class.getName()+ "' or '"+ Serializable.class.getName()+ "' nor does it have a custom field serializer",null);
        }
      }
    }
  }
}
