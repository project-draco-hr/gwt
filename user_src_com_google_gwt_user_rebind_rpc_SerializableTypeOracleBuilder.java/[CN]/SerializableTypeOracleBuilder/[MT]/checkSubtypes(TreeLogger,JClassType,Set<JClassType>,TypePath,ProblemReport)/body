{
  JClassType baseType=getBaseType(originalType);
  TreeLogger computationLogger=logger.branch(TreeLogger.DEBUG,"Finding possibly instantiable subtypes");
  List<JClassType> candidates=getPossiblyInstantiableSubtypes(computationLogger,baseType,problems);
  boolean anySubtypes=false;
  TreeLogger verificationLogger=logger.branch(TreeLogger.DEBUG,"Verifying instantiability");
  for (  JClassType candidate : candidates) {
    if (getBaseType(candidate) == baseType && originalType.isRawType() == null) {
      candidate=originalType;
    }
 else {
      candidate=constrainTypeBy(candidate,originalType);
      if (candidate == null) {
        continue;
      }
    }
    if (!isAllowedByFilter(candidate,problems)) {
      continue;
    }
    TypePath subtypePath=TypePaths.createSubtypePath(path,candidate,originalType);
    TypeInfoComputed tic=ensureTypeInfoComputed(candidate,subtypePath);
    if (tic.isDone()) {
      if (tic.isInstantiable()) {
        anySubtypes=true;
        instSubtypes.add(candidate);
      }
      continue;
    }
 else     if (tic.isPendingInstantiable()) {
      anySubtypes=true;
      instSubtypes.add(candidate);
      continue;
    }
    tic.setPendingInstantiable();
    TreeLogger subtypeLogger=verificationLogger.branch(TreeLogger.DEBUG,candidate.getParameterizedQualifiedSourceName());
    boolean instantiable=checkSubtype(subtypeLogger,candidate,originalType,subtypePath,problems);
    anySubtypes|=instantiable;
    tic.setInstantiable(instantiable);
    if (instantiable) {
      subtypeLogger.branch(TreeLogger.DEBUG,"Is instantiable");
    }
    if (instantiable) {
      instSubtypes.add(candidate);
    }
  }
  return anySubtypes;
}
