{
  try {
    JClassType stringType=typeOracle.getType(String.class.getName());
    if (!checkTypeInstantiable(rootLogger,stringType,false)) {
      throw new UnableToCompleteException();
    }
    JClassType icseType=typeOracle.getType(IncompatibleRemoteServiceException.class.getName());
    if (!checkTypeInstantiable(rootLogger,icseType,false)) {
      throw new UnableToCompleteException();
    }
  }
 catch (  NotFoundException e) {
    rootLogger.log(TreeLogger.ERROR,null,e);
    throw new UnableToCompleteException();
  }
  TreeLogger logger=rootLogger.branch(TreeLogger.DEBUG,"Analyzing '" + remoteService.getParameterizedQualifiedSourceName() + "' for serializable types",null);
  alreadyCheckedObject=false;
  validateRemoteService(logger,remoteService);
  List<TypeInfoComputed> typeInfoComputed=new ArrayList<TypeInfoComputed>(typeToTypeInfoComputed.values());
  for (  TypeInfoComputed tic : typeInfoComputed) {
    if (tic.isInstantiable()) {
      JArrayType arrayType=tic.getType().isArray();
      if (arrayType != null) {
        JType leafType=arrayType.getLeafType();
        int rank=arrayType.getRank();
        JClassType classType=leafType.isClassOrInterface();
        if (classType != null) {
          List<JClassType> instantiableSubTypes=new ArrayList<JClassType>();
          JClassType[] subTypes=classType.getSubtypes();
          for (int i=0; i < subTypes.length; ++i) {
            if (getTypeInfoComputed(subTypes[i]).isInstantiable()) {
              instantiableSubTypes.add(subTypes[i]);
            }
          }
          List<JClassType> covariantTypes=getAllTypesBetweenRootTypeAndLeaves(classType,instantiableSubTypes);
          for (int i=0, c=covariantTypes.size(); i < c; ++i) {
            JArrayType covariantArray=getArrayType(typeOracle,rank,covariantTypes.get(i));
            getTypeInfoComputed(covariantArray).setInstantiable(true);
          }
        }
      }
    }
  }
  Set<JClassType> possiblyInstantiatedTypes=new HashSet<JClassType>();
  List<JClassType> serializableTypesList=new ArrayList<JClassType>();
  for (  TypeInfoComputed tic : typeToTypeInfoComputed.values()) {
    JClassType type=tic.getType();
    if (type.isTypeParameter() != null || type.isWildcard() != null) {
      continue;
    }
    if (type.isParameterized() != null) {
      type=type.isParameterized().getRawType();
    }
    if (tic.isInstantiable()) {
      possiblyInstantiatedTypes.add(type);
    }
    if (tic.isFieldSerializable()) {
      serializableTypesList.add(type);
    }
  }
  JClassType[] serializableTypes=new JClassType[serializableTypesList.size()];
  serializableTypesList.toArray(serializableTypes);
  Arrays.sort(serializableTypes,new Comparator<JType>(){
    public int compare(    JType o1,    JType o2){
      String n1=o1.getQualifiedSourceName();
      String n2=o2.getQualifiedSourceName();
      return n1.compareTo(n2);
    }
  }
);
  logSerializableTypes(logger,serializableTypes);
  return new SerializableTypeOracleImpl(typeOracle,serializableTypes,possiblyInstantiatedTypes);
}
