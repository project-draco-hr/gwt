{
  JClassType baseType=getBaseType(originalType);
  TreeLogger computationLogger=logger.branch(TreeLogger.DEBUG,"Finding possibly instantiable subtypes");
  List<JClassType> candidates=getPossiblyInstantiableSubtypes(computationLogger,baseType);
  boolean anySubtypes=false;
  TreeLogger verificationLogger=logger.branch(TreeLogger.DEBUG,"Verifying instantiability");
  for (  JClassType candidate : candidates) {
    if (getBaseType(candidate) == baseType && originalType.isRawType() == null) {
      candidate=originalType;
    }
 else {
      candidate=constrainTypeBy(candidate,originalType);
      if (candidate == null) {
        continue;
      }
    }
    if (!isAllowedByFilter(verificationLogger,candidate,true)) {
      continue;
    }
    TypePath subtypePath=TypePaths.createSubtypePath(path,candidate,originalType);
    TypeInfoComputed tic=getTypeInfoComputed(candidate,subtypePath);
    if (tic.isDone()) {
      anySubtypes|=tic.isInstantiable();
      continue;
    }
 else     if (tic.isPendingInstantiable()) {
      anySubtypes=true;
      continue;
    }
    tic.setPendingInstantiable();
    TreeLogger subtypeLogger=verificationLogger.branch(TreeLogger.DEBUG,candidate.getParameterizedQualifiedSourceName());
    boolean instantiable=checkSubtype(subtypeLogger,candidate,originalType,true,subtypePath);
    anySubtypes|=instantiable;
    tic.setInstantiable(instantiable);
    if (instantiable) {
      subtypeLogger.branch(TreeLogger.DEBUG,"Is instantiable");
    }
    if (instantiable && instSubtypes != null) {
      instSubtypes.add(candidate);
    }
  }
  return anySubtypes;
}
