{
  assert(type != null);
  if (type.isPrimitive() != null) {
    return true;
  }
  assert(type instanceof JClassType);
  JClassType classType=(JClassType)type;
  TreeLogger localLogger=logger.branch(TreeLogger.DEBUG,classType.getParameterizedQualifiedSourceName(),null);
  JTypeParameter isTypeParameter=classType.isTypeParameter();
  if (isTypeParameter != null) {
    if (typeParametersInRootTypes.contains(isTypeParameter)) {
      return checkTypeInstantiable(localLogger,isTypeParameter.getFirstBound(),isSpeculative,TypePaths.createTypeParameterInRootPath(path,isTypeParameter),instSubtypes);
    }
    return true;
  }
  JWildcardType isWildcard=classType.isWildcard();
  if (isWildcard != null) {
    boolean success=true;
    for (    JClassType bound : isWildcard.getUpperBounds()) {
      success&=checkTypeInstantiable(localLogger,bound,isSpeculative,path);
    }
    return success;
  }
  JArrayType isArray=classType.isArray();
  if (isArray != null) {
    return checkArrayInstantiable(localLogger,isArray,isSpeculative,path);
  }
  if (classType == typeOracle.getJavaLangObject()) {
    localLogger.branch(getLogLevel(isSpeculative),"In order to produce smaller client-side code, 'Object' is not allowed; consider using a more specific type",null);
    return false;
  }
  if (classType.isRawType() != null) {
    localLogger.branch(TreeLogger.DEBUG,"Type '" + classType.getQualifiedSourceName() + "' should be parameterized to help the compiler produce the smallest code size possible for your module",null);
  }
  JClassType originalType=(JClassType)type;
  if (isSpeculative && isDirectlySerializable(originalType)) {
    isSpeculative=false;
  }
  boolean anySubtypes=checkSubtypes(localLogger,originalType,instSubtypes,path);
  if (!anySubtypes && !isSpeculative) {
    localLogger.branch(getLogLevel(isSpeculative),"Type '" + classType.getParameterizedQualifiedSourceName() + "' was not serializable and has no concrete serializable subtypes",null);
  }
  return anySubtypes;
}
