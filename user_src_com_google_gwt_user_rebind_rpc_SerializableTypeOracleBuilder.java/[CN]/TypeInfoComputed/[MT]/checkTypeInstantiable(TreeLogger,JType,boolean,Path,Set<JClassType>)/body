{
  assert(type != null);
  if (type.isPrimitive() != null) {
    return true;
  }
  assert(type instanceof JClassType);
  JClassType classType=(JClassType)type;
  TreeLogger localLogger=logger.branch(TreeLogger.DEBUG,classType.getParameterizedQualifiedSourceName(),null);
  if (!isAllowedByFilter(localLogger,classType,isSpeculative)) {
    return false;
  }
  JTypeParameter isTypeParameter=classType.isTypeParameter();
  if (isTypeParameter != null) {
    if (typeParametersInRootTypes.contains(isTypeParameter)) {
      return checkTypeInstantiable(localLogger,isTypeParameter.getFirstBound(),isSpeculative,path);
    }
    return true;
  }
  JWildcardType isWildcard=classType.isWildcard();
  if (isWildcard != null) {
    boolean success=true;
    for (    JClassType bound : isWildcard.getUpperBounds()) {
      success&=checkTypeInstantiable(localLogger,bound,isSpeculative,path);
    }
    return success;
  }
  TypeInfoComputed tic=getTypeInfoComputed(classType,path);
  if (tic.isPendingInstantiable()) {
    return true;
  }
 else   if (tic.isDone()) {
    return tic.hasInstantiableSubtypes();
  }
  tic.setPendingInstantiable();
  JArrayType isArray=classType.isArray();
  if (isArray != null) {
    return checkArrayInstantiable(localLogger,tic,isSpeculative,path);
  }
  if (classType == typeOracle.getJavaLangObject()) {
    localLogger.branch(getLogLevel(isSpeculative),"In order to produce smaller client-side code, 'Object' is not allowed; consider using a more specific type",null);
    tic.setInstantiable(false);
    return false;
  }
  if (classType.isRawType() != null) {
    TreeLogger rawTypeLogger=localLogger.branch(TreeLogger.DEBUG,"Type '" + classType.getQualifiedSourceName() + "' should be parameterized to help the compiler produce the smallest code size possible for your module",null);
    if (classType.isAssignableTo(collectionClass) || classType.isAssignableTo(mapClass)) {
      checkAllSubtypesOfObject(rawTypeLogger,path);
    }
  }
  JClassType originalType=(JClassType)type;
  JRealClassType baseType;
  if (type.isRawType() != null) {
    baseType=type.isRawType().getBaseType();
  }
 else   if (type.isParameterized() != null) {
    baseType=type.isParameterized().getBaseType();
  }
 else {
    baseType=(JRealClassType)originalType;
  }
  if (isSpeculative && tic.isDirectlySerializable()) {
    isSpeculative=false;
  }
  JClassType[] typeArgs=NO_JCLASSES;
  JParameterizedType isParameterized=originalType.isParameterized();
  JGenericType baseAsGenericType=baseType.isGenericType();
  if (isParameterized != null) {
    typeArgs=isParameterized.getTypeArgs();
  }
 else   if (baseAsGenericType != null) {
    List<JClassType> arguments=new ArrayList<JClassType>();
    for (    JTypeParameter typeParameter : baseAsGenericType.getTypeParameters()) {
      arguments.add(typeParameter.getFirstBound());
    }
    typeArgs=arguments.toArray(NO_JCLASSES);
  }
  boolean parametersOkay=true;
  JRawType isRaw=originalType.isRawType();
  if (isParameterized != null || isRaw != null) {
    assert(baseAsGenericType != null);
    int numDeclaredParams=baseAsGenericType.getTypeParameters().length;
    if (numDeclaredParams == typeArgs.length) {
      for (int i=0; i < numDeclaredParams; ++i) {
        JClassType typeArg=typeArgs[i];
        parametersOkay&=checkTypeArgument(localLogger,baseAsGenericType,i,typeArg,isSpeculative,path);
      }
    }
 else {
      for (int i=0; i < numDeclaredParams; ++i) {
        JClassType typeArg=typeArgs[i];
        parametersOkay&=checkTypeInstantiable(localLogger,typeArg,isSpeculative,path);
      }
    }
  }
  boolean isFieldSerializable=parametersOkay && shouldConsiderFieldsForSerialization(localLogger,baseType,isSpeculative) && checkFields(localLogger,baseType,isSpeculative,path);
  boolean isInstantiable=isFieldSerializable && canBeInstantiated(localLogger,baseType,TreeLogger.WARN);
  boolean anySubtypes=false;
  if (parametersOkay && baseType.getSubtypes().length > 0) {
    TreeLogger subtypesLogger=localLogger.branch(TreeLogger.DEBUG,"Analyzing subclasses:",null);
    anySubtypes=checkSubtypes(subtypesLogger,originalType,baseType,instSubtypes,typeArgs,path,baseType,false,isFieldSerializable);
  }
  anySubtypes|=isInstantiable;
  tic.setInstantiable(isInstantiable);
  tic.setInstantiableSubytpes(anySubtypes);
  if (!anySubtypes && !isSpeculative) {
    localLogger.branch(getLogLevel(isSpeculative),"Type '" + classType.getParameterizedQualifiedSourceName() + "' was not serializable and has no concrete serializable subtypes",null);
  }
  return tic.hasInstantiableSubtypes();
}
