{
  JArrayType typeArgAsArray=typeArg.isArray();
  if (typeArgAsArray != null) {
    JTypeParameter parameterOfTypeArgArray=typeArgAsArray.getLeafType().isTypeParameter();
    if (parameterOfTypeArgArray != null) {
      JGenericType declaringClass=parameterOfTypeArgArray.getDeclaringClass();
      if (declaringClass != null) {
        TypeParameterFlowInfo flowInfoForArrayParam=getFlowInfo(declaringClass,parameterOfTypeArgArray.getOrdinal());
        TypeParameterFlowInfo otherFlowInfo=getFlowInfo(baseType,paramIndex);
        if (otherFlowInfo.getExposure() >= 0 && flowInfoForArrayParam.infiniteArrayExpansionPathBetween(otherFlowInfo)) {
          logger.branch(getLogLevel(isSpeculative),"Cannot serialize type '" + baseType.getParameterizedQualifiedSourceName() + "' when given an argument of type '"+ typeArg.getParameterizedQualifiedSourceName()+ "' because it appears to require serializing arrays of unbounded dimension");
          return false;
        }
      }
    }
  }
  Path path=createTypeArgumentPath(parent,baseType,paramIndex,typeArg);
  int exposure=getTypeParameterExposure(baseType,paramIndex);
switch (exposure) {
case EXPOSURE_DIRECT:
{
      TreeLogger branch=logger.branch(TreeLogger.DEBUG,"Checking type argument " + paramIndex + " of type '"+ baseType.getParameterizedQualifiedSourceName()+ "' because it is directly exposed in this type or in one of its subtypes");
      return checkTypeInstantiable(branch,typeArg,true,path) || mightNotBeExposed(baseType,paramIndex);
    }
case EXPOSURE_NONE:
  logger.branch(TreeLogger.DEBUG,"Ignoring type argument " + paramIndex + " of type '"+ baseType.getParameterizedQualifiedSourceName()+ "' because it is not exposed in this or any subtype");
return true;
default :
{
assert(exposure >= EXPOSURE_MIN_BOUNDED_ARRAY);
TreeLogger branch=logger.branch(TreeLogger.DEBUG,"Checking type argument " + paramIndex + " of type '"+ baseType.getParameterizedQualifiedSourceName()+ "' because it is exposed as an array with a maximum dimension of "+ exposure+ " in this type or one of its subtypes");
return checkTypeInstantiable(branch,getArrayType(typeOracle,exposure,typeArg),true,path) || mightNotBeExposed(baseType,paramIndex);
}
}
}
