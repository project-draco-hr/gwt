{
  LowLevelSaf.pushJsContext(jsContext);
  JsValue jsthis=new JsValueSaf(jsthisInt);
  JsValue jsargs[]=new JsValue[jsargsInt.length];
  for (int i=0; i < jsargsInt.length; ++i) {
    jsargs[i]=new JsValueSaf(jsargsInt[i]);
  }
  JsValueSaf returnValue=new JsValueSaf();
  try {
    Class<?>[] paramTypes=method.getParameterTypes();
    int argc=paramTypes.length;
    Object args[]=new Object[argc];
    if (jsargs.length < argc) {
      throw new RuntimeException("Not enough arguments to " + method);
    }
    Object jthis=null;
    if (method.needsThis()) {
      jthis=JsValueGlue.get(jsthis,classLoader,method.getDeclaringClass(),"invoke this");
    }
    for (int i=0; i < argc; ++i) {
      args[i]=JsValueGlue.get(jsargs[i],classLoader,paramTypes[i],"invoke args");
    }
    try {
      Object result;
      try {
        result=method.invoke(jthis,args);
      }
 catch (      IllegalAccessException e) {
        e.printStackTrace();
        throw new RuntimeException(e);
      }
      JsValueGlue.set(returnValue,classLoader,method.getReturnType(),result);
      int jsResult=returnValue.getJsValue();
      LowLevelSaf.gcProtect(jsContext,jsResult);
      return jsResult;
    }
 catch (    InstantiationException e) {
      ModuleSpace.setThrownJavaException(e.getCause());
      exception[0]=LowLevelSaf.getJsNull(jsContext);
      return LowLevelSaf.getJsUndefined(jsContext);
    }
catch (    InvocationTargetException e) {
      Throwable t=e.getTargetException();
      ModuleSpace.setThrownJavaException(t);
      exception[0]=LowLevelSaf.getJsNull(jsContext);
      return LowLevelSaf.getJsUndefined(jsContext);
    }
  }
  finally {
    LowLevelSaf.popJsContext(jsContext);
  }
}
