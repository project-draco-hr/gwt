{
  if (!testCaseClass.equals(ReflectiveWebModeCompilerTestCase.class)) {
    Class superClass=testCaseClass.getSuperclass();
    if (superClass != null)     ctorMapPackagesInTestCase(superClass);
  }
  Class[] nestedClasses=testCaseClass.getDeclaredClasses();
  for (int i=0; i < nestedClasses.length; i++) {
    Class nestedClass=nestedClasses[i];
    String nestedClassName=nestedClass.getName();
    int indexOfSimpleName=nestedClassName.lastIndexOf('$') + 1;
    nestedClassName=nestedClassName.substring(indexOfSimpleName);
    if (nestedClassName.startsWith("Package_")) {
      int modifiers=nestedClass.getModifiers();
      if (Modifier.isStatic(modifiers) && Modifier.isPublic(modifiers)) {
        Map methodMap=(Map)methodMapByPackageName.get(nestedClassName);
        if (methodMap == null) {
          methodMap=new HashMap();
          methodMapByPackageName.put(nestedClassName,methodMap);
        }
        ctorMapMethodsInPackage(nestedClass,methodMap);
      }
 else {
        System.err.println("Package class " + nestedClassName + " in class "+ testCaseClass.getName()+ " should be 'public' and 'static'");
      }
    }
  }
}
