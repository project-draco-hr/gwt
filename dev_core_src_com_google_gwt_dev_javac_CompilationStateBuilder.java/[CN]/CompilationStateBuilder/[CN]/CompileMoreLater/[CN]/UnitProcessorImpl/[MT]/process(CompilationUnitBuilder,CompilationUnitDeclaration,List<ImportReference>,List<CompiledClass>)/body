{
  Event event=SpeedTracerLogger.start(DevModeEventType.CSB_PROCESS);
  try {
    List<JDeclaredType> types=ImmutableList.of();
    final Set<String> jsniDeps=Sets.newHashSet();
    final Map<String,Binding> jsniRefs=Maps.newHashMap();
    Map<MethodDeclaration,JsniMethod> jsniMethods=ImmutableMap.of();
    List<String> apiRefs=ImmutableList.of();
    MethodArgNamesLookup methodArgs=new MethodArgNamesLookup();
    if (!cud.compilationResult().hasErrors()) {
      jsniMethods=JsniMethodCollector.collectJsniMethods(cud,builder.getSourceMapPath(),builder.getSource(),JsRootScope.INSTANCE,DummyCorrelationFactory.INSTANCE);
      JSORestrictionsChecker.check(jsoState,cud);
      JsniReferenceResolver.resolve(cud,cudOriginaImports,jsoState,jsniMethods,jsniRefs,new JsniReferenceResolver.TypeResolver(){
        @Override public ReferenceBinding resolveType(        String sourceOrBinaryName){
          ReferenceBinding resolveType=compiler.resolveType(sourceOrBinaryName);
          if (resolveType != null) {
            jsniDeps.add(String.valueOf(resolveType.qualifiedSourceName()));
          }
          return resolveType;
        }
      }
);
      if (compilerContext.shouldCompileMonolithic()) {
        BinaryTypeReferenceRestrictionsChecker.check(cud);
      }
      if (!cud.compilationResult().hasErrors()) {
        types=astBuilder.process(cud,builder.getSourceMapPath(),jsniMethods,jsniRefs,compilerContext);
      }
      methodArgs=MethodParamCollector.collect(cud,builder.getSourceMapPath());
    }
    apiRefs=compiler.collectApiRefs(cud);
    final Interner<String> interner=StringInterner.get();
    String packageName=interner.intern(Shared.getPackageName(builder.getTypeName()));
    List<String> unresolvedSimple=Lists.newArrayList();
    for (    char[] simpleRef : cud.compilationResult().simpleNameReferences) {
      unresolvedSimple.add(interner.intern(String.valueOf(simpleRef)));
    }
    List<String> unresolvedQualified=Lists.newArrayList();
    for (    char[][] qualifiedRef : cud.compilationResult().qualifiedReferences) {
      unresolvedQualified.add(interner.intern(CharOperation.toString(qualifiedRef)));
    }
    for (    String jsniDep : jsniDeps) {
      unresolvedQualified.add(interner.intern(jsniDep));
    }
    for (int i=0; i < apiRefs.size(); ++i) {
      apiRefs.set(i,interner.intern(apiRefs.get(i)));
    }
    Dependencies dependencies=new Dependencies(packageName,unresolvedQualified,unresolvedSimple,apiRefs);
    for (    CompiledClass cc : compiledClasses) {
      allValidClasses.put(cc.getSourceName(),cc);
    }
    builder.setTypes(types).setDependencies(dependencies).setJsniMethods(jsniMethods.values()).setMethodArgs(methodArgs).setClasses(compiledClasses).setProblems(cud.compilationResult().getProblems());
    buildQueue.add(builder);
  }
  finally {
    event.end();
  }
}
