{
  Event event=SpeedTracerLogger.start(DevModeEventType.CSB_PROCESS);
  try {
    Map<MethodDeclaration,JsniMethod> jsniMethods=JsniCollector.collectJsniMethods(cud,builder.getSourceMapPath(),builder.getSource(),JsRootScope.INSTANCE,DummyCorrelationFactory.INSTANCE);
    JSORestrictionsChecker.check(jsoState,cud);
    final Set<String> jsniDeps=new HashSet<String>();
    Map<String,Binding> jsniRefs=new HashMap<String,Binding>();
    JsniChecker.check(cud,cudOriginaImports,jsoState,jsniMethods,jsniRefs,new JsniChecker.TypeResolver(){
      @Override public ReferenceBinding resolveType(      String sourceOrBinaryName){
        ReferenceBinding resolveType=compiler.resolveType(sourceOrBinaryName);
        if (resolveType != null) {
          jsniDeps.add(String.valueOf(resolveType.qualifiedSourceName()));
        }
        return resolveType;
      }
    }
);
    Map<TypeDeclaration,Binding[]> artificialRescues=new HashMap<TypeDeclaration,Binding[]>();
    ArtificialRescueChecker.check(cud,builder.isGenerated(),artificialRescues);
    if (compilerContext.shouldCompileMonolithic()) {
      BinaryTypeReferenceRestrictionsChecker.check(cud);
    }
    MethodArgNamesLookup methodArgs=MethodParamCollector.collect(cud,builder.getSourceMapPath());
    Interner<String> interner=StringInterner.get();
    String packageName=interner.intern(Shared.getPackageName(builder.getTypeName()));
    List<String> unresolvedQualified=new ArrayList<String>();
    List<String> unresolvedSimple=new ArrayList<String>();
    for (    char[] simpleRef : cud.compilationResult().simpleNameReferences) {
      unresolvedSimple.add(interner.intern(String.valueOf(simpleRef)));
    }
    for (    char[][] qualifiedRef : cud.compilationResult().qualifiedReferences) {
      unresolvedQualified.add(interner.intern(CharOperation.toString(qualifiedRef)));
    }
    for (    String jsniDep : jsniDeps) {
      unresolvedQualified.add(interner.intern(jsniDep));
    }
    ArrayList<String> apiRefs=compiler.collectApiRefs(cud);
    for (int i=0; i < apiRefs.size(); ++i) {
      apiRefs.set(i,interner.intern(apiRefs.get(i)));
    }
    Dependencies dependencies=new Dependencies(packageName,unresolvedQualified,unresolvedSimple,apiRefs);
    List<JDeclaredType> types=Collections.emptyList();
    if (!cud.compilationResult().hasErrors()) {
      types=astBuilder.process(cud,builder.getSourceMapPath(),artificialRescues,jsniMethods,jsniRefs);
    }
    for (    CompiledClass cc : compiledClasses) {
      allValidClasses.put(cc.getSourceName(),cc);
    }
    builder.setClasses(compiledClasses).setTypes(types).setDependencies(dependencies).setJsniMethods(jsniMethods.values()).setMethodArgs(methodArgs).setProblems(cud.compilationResult().getProblems());
    buildQueue.add(builder);
  }
  finally {
    event.end();
  }
}
