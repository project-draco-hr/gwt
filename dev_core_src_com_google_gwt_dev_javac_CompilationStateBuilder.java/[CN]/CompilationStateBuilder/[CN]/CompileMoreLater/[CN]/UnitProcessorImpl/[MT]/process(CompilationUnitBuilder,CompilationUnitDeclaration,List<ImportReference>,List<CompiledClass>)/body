{
  Event event=SpeedTracerLogger.start(DevModeEventType.CSB_PROCESS);
  try {
    if (!cud.compilationResult().hasErrors()) {
      Map<MethodDeclaration,JsniMethod> jsniMethods=JsniMethodCollector.collectJsniMethods(cud,builder.getSourceMapPath(),builder.getSource(),JsRootScope.INSTANCE,DummyCorrelationFactory.INSTANCE);
      JSORestrictionsChecker.check(jsoState,cud);
      final Set<String> jsniDeps=Sets.newHashSet();
      final Map<String,Binding> jsniRefs=Maps.newHashMap();
      JsniReferenceResolver.resolve(cud,cudOriginaImports,jsoState,jsniMethods,jsniRefs,new JsniReferenceResolver.TypeResolver(){
        @Override public ReferenceBinding resolveType(        String sourceOrBinaryName){
          ReferenceBinding resolveType=compiler.resolveType(sourceOrBinaryName);
          if (resolveType != null) {
            jsniDeps.add(String.valueOf(resolveType.qualifiedSourceName()));
          }
          return resolveType;
        }
      }
);
      final Map<TypeDeclaration,Binding[]> artificialRescues=Maps.newHashMap();
      ArtificialRescueChecker.check(cud,builder.isGenerated(),artificialRescues);
      if (compilerContext.shouldCompileMonolithic()) {
        BinaryTypeReferenceRestrictionsChecker.check(cud);
      }
      MethodArgNamesLookup methodArgs=MethodParamCollector.collect(cud,builder.getSourceMapPath());
      final Interner<String> interner=StringInterner.get();
      String packageName=interner.intern(Shared.getPackageName(builder.getTypeName()));
      List<String> unresolvedSimple=Lists.newArrayList();
      for (      char[] simpleRef : cud.compilationResult().simpleNameReferences) {
        unresolvedSimple.add(interner.intern(String.valueOf(simpleRef)));
      }
      List<String> unresolvedQualified=Lists.newArrayList();
      for (      char[][] qualifiedRef : cud.compilationResult().qualifiedReferences) {
        unresolvedQualified.add(interner.intern(CharOperation.toString(qualifiedRef)));
      }
      for (      String jsniDep : jsniDeps) {
        unresolvedQualified.add(interner.intern(jsniDep));
      }
      List<String> apiRefs=compiler.collectApiRefs(cud);
      for (int i=0; i < apiRefs.size(); ++i) {
        apiRefs.set(i,interner.intern(apiRefs.get(i)));
      }
      Dependencies dependencies=new Dependencies(packageName,unresolvedQualified,unresolvedSimple,apiRefs);
      List<JDeclaredType> types=ImmutableList.of();
      if (!cud.compilationResult().hasErrors()) {
        types=astBuilder.process(cud,builder.getSourceMapPath(),artificialRescues,jsniMethods,jsniRefs);
      }
      for (      CompiledClass cc : compiledClasses) {
        allValidClasses.put(cc.getSourceName(),cc);
      }
      builder.setTypes(types).setDependencies(dependencies).setJsniMethods(jsniMethods.values()).setMethodArgs(methodArgs).setClasses(compiledClasses).setProblems(cud.compilationResult().getProblems());
    }
 else {
      builder.setTypes(Collections.<JDeclaredType>emptyList()).setDependencies(new Dependencies()).setJsniMethods(Collections.<JsniMethod>emptyList()).setMethodArgs(new MethodArgNamesLookup()).setClasses(compiledClasses).setProblems(cud.compilationResult().getProblems());
    }
    buildQueue.add(builder);
  }
  finally {
    event.end();
  }
}
