{
  UnitCache unitCache=compilerContext.getUnitCache();
  for (  CompilationUnit unit : cachedUnits.values()) {
    for (    CompiledClass cc : unit.getCompiledClasses()) {
      String sourceName=cc.getSourceName();
      allValidClasses.put(sourceName,cc);
    }
  }
  List<CompilationUnit> resultUnits=Lists.newArrayList();
  do {
    final TreeLogger branch=logger.branch(TreeLogger.TRACE,"Compiling...");
    buildQueue=new LinkedBlockingQueue<CompilationUnitBuilder>();
    final List<CompilationUnit> newlyBuiltUnits=Lists.newArrayList();
    final CompilationUnitBuilder sentinel=CompilationUnitBuilder.create((GeneratedUnit)null);
    final Throwable[] workerException=new Throwable[1];
    final ProgressLogger progressLogger=new ProgressLogger(branch,TreeLogger.TRACE,builders.size(),10);
    Thread buildThread=new Thread(){
      @Override public void run(){
        int processedCompilationUnitBuilders=0;
        try {
          do {
            CompilationUnitBuilder builder=buildQueue.take();
            if (!progressLogger.isTimerStarted()) {
              progressLogger.startTimer();
            }
            if (builder == sentinel) {
              return;
            }
            CompilationUnit unit=builder.build();
            newlyBuiltUnits.add(unit);
            processedCompilationUnitBuilders++;
            progressLogger.updateProgress(processedCompilationUnitBuilders);
          }
 while (true);
        }
 catch (        Throwable e) {
          workerException[0]=e;
        }
      }
    }
;
    buildThread.setName("CompilationUnitBuilder");
    buildThread.start();
    Event jdtCompilerEvent=SpeedTracerLogger.start(eventType);
    long compilationStartNanos=System.nanoTime();
    try {
      compiler.doCompile(branch,builders);
    }
  finally {
      jdtCompilerEvent.end();
    }
    buildQueue.add(sentinel);
    try {
      buildThread.join();
      long compilationNanos=System.nanoTime() - compilationStartNanos;
      double compilationSeconds=compilationNanos / (double)TimeUnit.SECONDS.toNanos(1);
      branch.log(TreeLogger.TRACE,String.format("Compilation completed in %.02f seconds",compilationSeconds));
      if (workerException[0] != null) {
        throw workerException[0];
      }
    }
 catch (    RuntimeException e) {
      throw e;
    }
catch (    Throwable e) {
      throw new RuntimeException("Exception processing units",e);
    }
 finally {
      buildQueue=null;
    }
    resultUnits.addAll(newlyBuiltUnits);
    builders.clear();
    for (    CompilationUnit unit : newlyBuiltUnits) {
      unit.getDependencies().resolve(allValidClasses);
    }
    removeInvalidCachedUnitsAndRescheduleCorrespondingBuilders(logger,builders,cachedUnits);
  }
 while (builders.size() > 0);
  for (  CompilationUnit unit : resultUnits) {
    unitCache.add(unit);
  }
  resultUnits.addAll(cachedUnits.values());
  unitCache.cleanup(logger);
  Collections.sort(resultUnits,CompilationUnit.COMPARATOR);
  logger=logger.branch(TreeLogger.DEBUG,"Validating units:");
  int errorCount=0;
  for (  CompilationUnit unit : resultUnits) {
    if (CompilationProblemReporter.reportErrors(logger,unit,suppressErrors)) {
      errorCount++;
    }
  }
  if (suppressErrors && errorCount > 0 && !logger.isLoggable(TreeLogger.TRACE) && logger.isLoggable(TreeLogger.INFO)) {
    logger.log(TreeLogger.INFO,"Ignored " + errorCount + " unit"+ (errorCount > 1 ? "s" : "")+ " with compilation errors in first pass.\n"+ "Compile with -strict or with -logLevel set to TRACE or DEBUG to see all errors.");
  }
  return resultUnits;
}
