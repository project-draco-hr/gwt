{
  for (  CompilationUnit unit : cachedUnits.values()) {
    for (    CompiledClass cc : unit.getCompiledClasses()) {
      String sourceName=cc.getSourceName();
      allValidClasses.put(sourceName,cc);
    }
  }
  Map<CompiledClass,CompiledClass> cachedStructurallySame=new IdentityHashMap<CompiledClass,CompiledClass>();
  ArrayList<CompilationUnit> resultUnits=new ArrayList<CompilationUnit>();
  do {
    this.newlyBuiltUnits=new ArrayList<CompilationUnit>();
    Event jdtCompilerEvent=SpeedTracerLogger.start(eventType);
    try {
      compiler.doCompile(builders);
    }
  finally {
      jdtCompilerEvent.end();
    }
    resultUnits.addAll(this.newlyBuiltUnits);
    builders.clear();
    for (    CompilationUnit unit : this.newlyBuiltUnits) {
      unit.getDependencies().resolve(allValidClasses);
    }
    Collection<CompilationUnit> invalidatedUnits=new ArrayList<CompilationUnit>();
    for (Iterator<Entry<CompilationUnitBuilder,CompilationUnit>> it=cachedUnits.entrySet().iterator(); it.hasNext(); ) {
      Entry<CompilationUnitBuilder,CompilationUnit> entry=it.next();
      CompilationUnit unit=entry.getValue();
      boolean isValid=unit.getDependencies().validate(allValidClasses,cachedStructurallySame);
      if (!isValid) {
        invalidatedUnits.add(unit);
        builders.add(entry.getKey());
        it.remove();
      }
    }
    for (    CompilationUnit unit : invalidatedUnits) {
      for (      CompiledClass cc : unit.getCompiledClasses()) {
        allValidClasses.remove(cc.getSourceName());
      }
    }
  }
 while (builders.size() > 0);
  resultUnits.addAll(cachedUnits.values());
  Collections.sort(resultUnits,CompilationUnit.COMPARATOR);
  logger=logger.branch(TreeLogger.DEBUG,"Validating newly compiled units");
  for (  CompilationUnit unit : resultUnits) {
    CompilationUnitInvalidator.reportErrors(logger,unit);
  }
  return resultUnits;
}
