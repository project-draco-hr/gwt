{
  boolean failed=false;
  finishBound();
  if (hasReturnType) {
    failed|=(returnType[0] == null);
    ((JMethod)method).setReturnType(returnType[0]);
  }
  List<CollectAnnotationData>[] argAnnotations=methodData.getArgAnnotations();
  if (argTypes.length != params.size()) {
    throw new IllegalStateException("Arg count mismatch between method descriptor (" + methodData.getDesc() + ") and signature ("+ methodData.getSignature()+ ")");
  }
  for (int i=0; i < argTypes.length; ++i) {
    JType argType=params.get(i)[0];
    if (argType == null) {
      failed=true;
      continue;
    }
    Map<Class<? extends Annotation>,Annotation> declaredAnnotations=new HashMap<Class<? extends Annotation>,Annotation>();
    resolver.resolveAnnotations(logger,argAnnotations[i],declaredAnnotations);
    new JParameter(method,argType,argNames[i],declaredAnnotations);
  }
  for (  JType[] exc : exceptions) {
    if (exc[0] == null) {
      failed=true;
      continue;
    }
    method.addThrows(exc[0]);
  }
  return !failed;
}
