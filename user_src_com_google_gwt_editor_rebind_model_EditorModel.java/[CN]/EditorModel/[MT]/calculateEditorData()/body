{
  List<EditorData> flatData=new ArrayList<EditorData>();
  List<EditorData> toReturn=new ArrayList<EditorData>();
  for (  JClassType type : editorType.getFlattenedSupertypeHierarchy()) {
    for (    JField field : type.getFields()) {
      if (field.isPrivate() || field.isStatic()) {
        continue;
      }
      JType fieldClassType=field.getType();
      if (shouldExamine(fieldClassType)) {
        List<EditorData> data=createEditorData(EditorAccess.via(field));
        flatData.addAll(data);
        toReturn.addAll(data);
        for (        EditorData d : data) {
          if (!d.isLeafValueEditor()) {
            descendIntoSubEditor(toReturn,d);
          }
        }
      }
    }
    for (    JMethod method : type.getMethods()) {
      if (method.isPrivate() || method.isStatic()) {
        continue;
      }
      JType methodReturnType=method.getReturnType();
      if (shouldExamine(methodReturnType) && method.getParameters().length == 0) {
        EditorAccess access=EditorAccess.via(method);
        if (access.getPath().equals("as") && isEditorIntf.isAssignableFrom(editorType)) {
          continue;
        }
        List<EditorData> data=createEditorData(access);
        flatData.addAll(data);
        toReturn.addAll(data);
        for (        EditorData d : data) {
          if (!d.isLeafValueEditor()) {
            descendIntoSubEditor(toReturn,d);
          }
        }
      }
    }
    type=type.getSuperclass();
  }
  if (!typeData.containsKey(editorType)) {
    typeData.put(editorType,flatData);
  }
  return toReturn.toArray(new EditorData[toReturn.size()]);
}
