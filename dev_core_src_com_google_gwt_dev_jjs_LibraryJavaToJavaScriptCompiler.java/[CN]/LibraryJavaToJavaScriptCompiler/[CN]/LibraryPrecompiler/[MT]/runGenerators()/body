{
  boolean globalCompile=compilerContext.getOptions().shouldLink();
  Set<Rule> generatorRules=Sets.newHashSet(module.getGeneratorRules());
  TreeLogger branch=logger.branch(TreeLogger.SPAM,"running generators");
  for (  Rule rule : generatorRules) {
    RuleGenerateWith generatorRule=(RuleGenerateWith)rule;
    String generatorName=generatorRule.getName();
    if (generatorRule.contentDependsOnTypes() && !globalCompile) {
      branch.log(TreeLogger.SPAM,"skipping generator " + generatorName + " since it can only run in the global phase");
      continue;
    }
    if (!generatorRule.relevantPropertiesAreFinal(module.getProperties(),options.getFinalProperties())) {
      branch.log(TreeLogger.SPAM,"skipping generator " + generatorName + " since properties it cares about have not reached their final values.");
      continue;
    }
    Set<String> reboundTypes=Sets.newHashSet(compilerContext.getReboundTypeSourceNames());
    Set<String> processedReboundTypeSourceNamesForGenerator=compilerContext.getProcessedReboundTypeSourceNames(generatorName);
    Set<String> unprocessedReboundTypeSourceNames=Sets.newHashSet(reboundTypes);
    unprocessedReboundTypeSourceNames.removeAll(processedReboundTypeSourceNamesForGenerator);
    if (unprocessedReboundTypeSourceNames.isEmpty()) {
      branch.log(TreeLogger.SPAM,"skipping generator " + generatorName + " since it has already processed all requested rebound types.");
      continue;
    }
    branch.log(TreeLogger.SPAM,"running generator " + generatorName + " on "+ unprocessedReboundTypeSourceNames.size()+ " not yet processed rebound types");
    runGenerator(generatorRule,unprocessedReboundTypeSourceNames);
    for (    String unprocessedReboundTypeSourceName : unprocessedReboundTypeSourceNames) {
      compilerContext.getLibraryWriter().markReboundTypeProcessed(unprocessedReboundTypeSourceName,generatorName);
    }
  }
  if (getGeneratorContext().isDirty()) {
    getGeneratorContext().finish(logger);
    return false;
  }
  return true;
}
