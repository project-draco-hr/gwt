{
  File[] cacheXmls=outDir.listFiles(new FilenameFilter(){
    public boolean accept(    File dir,    String name){
      return name.endsWith(EXT_CACHE_XML);
    }
  }
);
  if (cacheXmls == null) {
    return;
  }
  long newestCup=jjs.getLastModifiedTimeOfNewestCompilationUnit();
  for (int i=0; i < cacheXmls.length; i++) {
    File cacheXml=cacheXmls[i];
    String fn=cacheXml.getName();
    String strongName=fn.substring(0,fn.length() - EXT_CACHE_XML.length());
    long cacheXmlLastMod=cacheXml.lastModified();
    if (cacheXmlLastMod < newestCup) {
      String msg="Compilation '" + fn + "' is out of date and will be removed";
      logger.log(TreeLogger.TRACE,msg,null);
      Util.deleteFilesStartingWith(outDir,strongName);
      continue;
    }
    TreeLogger branch=logger.branch(TreeLogger.DEBUG,"Loading cached compilation: " + cacheXml,null);
    Compilation c=new Compilation();
    c.setStrongName(strongName);
    CompilationSchema schema=new CompilationSchema(c);
    FileReader r=null;
    Throwable caught=null;
    try {
      r=new FileReader(cacheXml);
      ReflectiveParser.parse(logger,schema,r);
    }
 catch (    FileNotFoundException e) {
      caught=e;
    }
catch (    UnableToCompleteException e) {
      caught=e;
    }
 finally {
      Utility.close(r);
    }
    if (caught != null) {
      String msg="Unable to load the cached file";
      branch.log(TreeLogger.WARN,msg,caught);
      continue;
    }
    boolean isBadCompilation=false;
    String[] genTypes=c.getGeneratedTypeNames();
    for (int j=0; j < genTypes.length; j++) {
      String genTypeName=genTypes[j];
      String cachedHash=c.getTypeHash(genTypeName);
      JClassType genType=typeOracle.findType(genTypeName);
      if (genType == null) {
        String msg="Compilation '" + fn + "' refers to generated type '"+ genTypeName+ "' which no longers exists; cache entry will be removed";
        branch.log(TreeLogger.TRACE,msg,null);
        Util.deleteFilesStartingWith(outDir,strongName);
        isBadCompilation=true;
        break;
      }
      String currentHash=genType.getTypeHash();
      if (!cachedHash.equals(currentHash)) {
        String msg="Compilation '" + fn + "' was compiled with a different version of generated source for '"+ genTypeName+ "'; cache entry will be removed";
        branch.log(TreeLogger.TRACE,msg,null);
        Util.deleteFilesStartingWith(outDir,strongName);
        isBadCompilation=true;
        break;
      }
    }
    if (!isBadCompilation) {
      compilations.add(c);
    }
  }
}
