{
  for (  String moduleName : Lists.newArrayList(directDepModuleNamesByModuleName.keySet())) {
    Set<String> libraryModules=Sets.newHashSet();
    Set<String> filesetsProcessed=Sets.newHashSet();
    Queue<LinkedList<String>> modulePathsToProcess=Queues.newArrayDeque();
    Collection<String> directDependencyModuleNames=directDepModuleNamesByModuleName.get(moduleName);
    for (    String directDependencyModuleName : directDependencyModuleNames) {
      modulePathsToProcess.add(Lists.newLinkedList(ImmutableList.of(directDependencyModuleName)));
    }
    while (!modulePathsToProcess.isEmpty()) {
      LinkedList<String> dependentModuleNamePath=modulePathsToProcess.poll();
      String dependentModuleName=dependentModuleNamePath.getLast();
      boolean isLibrary=!filesetModuleNames.contains(dependentModuleName);
      if (isLibrary) {
        if (!moduleName.equals(dependentModuleName)) {
          libraryModules.add(dependentModuleName);
          dependentModuleNamePath.removeLast();
          filesetPathPerEdge.putAll(new LibraryDependencyEdge(moduleName,dependentModuleName),dependentModuleNamePath);
        }
        continue;
      }
      filesetsProcessed.add(dependentModuleName);
      Set<String> unProcessedModules=Sets.newHashSet(directDepModuleNamesByModuleName.get(dependentModuleName));
      unProcessedModules.removeAll(filesetsProcessed);
      for (      String unProcessedModule : unProcessedModules) {
        modulePathsToProcess.add(createExtendedCopy(dependentModuleNamePath,unProcessedModule));
      }
    }
    directDepModuleNamesByModuleName.replaceValues(moduleName,libraryModules);
  }
  directDepModuleNamesByModuleName.removeAll(filesetModuleNames);
}
